<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="从零开始">
<meta property="og:url" content="http://b.zhongmin.me/page/10/index.html">
<meta property="og:site_name" content="从零开始">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从零开始">





  
  
  <link rel="canonical" href="http://b.zhongmin.me/page/10/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>从零开始</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br/>日程表</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/03/11/linux-e4-b8-8b-e4-bd-bf-e7-94-a8-nginx-e5-88-9b-e5-bb-ba-e8-99-9a-e6-8b-9f-e9-9d-99-e6-80-81-e6-9c-8d-e5-8a-a1-e5-99-a8/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/11/linux-e4-b8-8b-e4-bd-bf-e7-94-a8-nginx-e5-88-9b-e5-bb-ba-e8-99-9a-e6-8b-9f-e9-9d-99-e6-80-81-e6-9c-8d-e5-8a-a1-e5-99-a8/" class="post-title-link" itemprop="url">Linux 下 使用 Nginx 创建虚拟静态服务器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-11 14:02:59" itemprop="dateCreated datePublished" datetime="2017-03-11T14:02:59+08:00">2017-03-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、什么是nginx"><a href="#一、什么是nginx" class="headerlink" title="一、什么是nginx"></a>一、什么是nginx</h3><p>是一个C语言开发的HTTP反向代理服务器，性能非常高</p>
<p>一个俄罗斯的哥们开发的，官方提供的测试性能能够达到5W的并发，我的天呐~，实际测试差不多是2W，而淘宝的牛人可以优化到200W</p>
<p>运行效率非常好，占用的资源也非常低，运行稳定</p>
<h3 id="二、Nginx的应用场景-有哪些"><a href="#二、Nginx的应用场景-有哪些" class="headerlink" title="二、Nginx的应用场景 有哪些"></a>二、Nginx的应用场景 有哪些</h3><p>1、http服务器：Nginx是一个http服务可以独立提供http服务，可以做网页静态服务器，你可以放一些静态资源，比如HTML, JS, CSS, 图片</p>
<p>2、虚拟主机：可以实现在一台服务器虚拟出多个网站，同时使用80端口</p>
<p>3、反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，这时需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载过高而宕机，也不会出现某台服务器闲置的情况。</p>
<h3 id="三、Nginx安装"><a href="#三、Nginx安装" class="headerlink" title="三、Nginx安装"></a>三、Nginx安装</h3><p>首先需要在虚拟机上安装Linux环境（怎么安装的，略…）（当然你也可以用Windows版本的，性能的话呢，呵呵）</p>
<p>首先要准备编译环境（bala bala …）</p>
<p>分别运行一下4条命令，至于是啥东西就不多说了，有兴趣的可以m我或者百度一下</p>
<p>yum install gcc-c++</p>
<p>yum install -y pcre pcre-devel</p>
<p>yum install -y zlib zlib-devel</p>
<p>yum install -y openssl openssl-devel</p>
<p>下载地址</p>
<p>进入<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<p>我目前使用的是1.81, 1.9 的新的不用</p>
<p>好，东风来了：</p>
<p>1. 把nginx的源码上传到linux系统</p>
<p>放在root下</p>
<p>2. 把压缩包解压缩</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/160419090827731.png" alt></p>
<p>3.在/var下新建/var/temp/nginx/目录</p>
<p>4. 进行configure配置</p>
<p>./configure \</p>
<p>–prefix=/usr/local/nginx \</p>
<p>–pid-path=/var/run/nginx/nginx.pid \</p>
<p>–lock-path=/var/lock/nginx.lock \</p>
<p>–error-log-path=/var/log/nginx/error.log \</p>
<p>–http-log-path=/var/log/nginx/access.log \</p>
<p>–with-http_gzip_static_module \</p>
<p>–http-client-body-temp-path=/var/temp/nginx/client \</p>
<p>–http-proxy-temp-path=/var/temp/nginx/proxy \</p>
<p>–http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</p>
<p>–http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</p>
<p>–http-scgi-temp-path=/var/temp/nginx/scgi</p>
<p>直接复制这一坨命令到putty（有很多SSH，随意用）</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/160419090827732.png" alt></p>
<p>运行结果：<img src="http://zhongmin.me/wp-content/uploads/2017/03/12.png" alt></p>
<p>此时已经有makefile文件夹了</p>
<p>5. make</p>
<p>进入 nginx-1.8.1文件夹，运行命令</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/12312.png" alt></p>
<p>编译成功<img src="http://zhongmin.me/wp-content/uploads/2017/03/123124124124.png" alt></p>
<p>6. make install</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/sss.png" alt></p>
<p>运行结果：<img src="http://zhongmin.me/wp-content/uploads/2017/03/makeinstall.png" alt></p>
<p>此时，在 /usr/local下会多一个nginx<img src="http://zhongmin.me/wp-content/uploads/2017/03/makeinstall2.png" alt></p>
<p>这时，我们可以使Nginx启动或停止</p>
<p>1. 启动：进入nginx的sbin目录，./nginx就可以直接启动</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/succ.png" alt></p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/start.png" alt></p>
<p>启动成功</p>
<p>PS：如果你的linux是新建的，那么防火墙是关闭的</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/fire.png" alt></p>
<p>关闭防火墙就可以访问该虚拟机的IP</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/nginxs.png" alt></p>
<p>我们开看一下这个文件</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/conf.png" alt></p>
<p>看看配置<img src="http://zhongmin.me/wp-content/uploads/2017/03/nginxconf.png" alt></p>
<p>新建一个server节点</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/newservice.png" alt></p>
<p>对应更目录，html_88</p>
<p><img src="http://zhongmin.me/wp-content/uploads/2017/03/html_88.png" alt></p>
<p>./nginx -s reload 刷一下<img src="http://zhongmin.me/wp-content/uploads/2017/03/succcs.png" alt></p>
<p>成功！</p>
<p>PS：如果访问不了可能是端口没开</p>
<p>打开88端口即可，这边就不多说了</p>
<p><strong>更多Nginx相关教程见以下内容</strong>：</p>
<p><a href="http://www.linuxidc.com/topicnews.aspx?tid=14" title="CentOS" target="_blank" rel="noopener">CentOS</a> 6.2实战部署Nginx+MySQL+PHP <a href="http://www.linuxidc.com/Linux/2013-09/90020.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/90020.htm</a> 使用Nginx搭建WEB服务器 <a href="http://www.linuxidc.com/Linux/2013-09/89768.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89768.htm</a> 搭建基于Linux6.3+Nginx1.2+PHP5+MySQL5.5的Web服务器全过程 <a href="http://www.linuxidc.com/Linux/2013-09/89692.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89692.htm</a> CentOS 6.3下Nginx性能调优 <a href="http://www.linuxidc.com/Linux/2013-09/89656.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89656.htm</a> CentOS 6.3下配置Nginx加载ngx_pagespeed模块 <a href="http://www.linuxidc.com/Linux/2013-09/89657.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-09/89657.htm</a> CentOS 6.4安装配置Nginx+Pcre+php-fpm <a href="http://www.linuxidc.com/Linux/2013-08/88984.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2013-08/88984.htm</a> Nginx安装配置使用详细笔记 <a href="http://www.linuxidc.com/Linux/2014-07/104499.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-07/104499.htm</a> Nginx日志过滤 使用ngx_log_if不记录特定日志 <a href="http://www.linuxidc.com/Linux/2014-07/104686.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-07/104686.htm</a> <strong>Nginx 的详细介绍</strong>：<a href="http://www.linuxidc.com/Linux/2012-03/56786.htm" title="Nginx" target="_blank" rel="noopener">请点这里</a> <strong>Nginx 的下载地址</strong>：<a href="http://www.linuxidc.com/down.aspx?id=342" target="_blank" rel="noopener">请点这里</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/03/09/jvectormap-api-e4-b9-8bworldmap/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/09/jvectormap-api-e4-b9-8bworldmap/" class="post-title-link" itemprop="url">JVectorMap API之WorldMap</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-09 12:37:20" itemprop="dateCreated datePublished" datetime="2017-03-09T12:37:20+08:00">2017-03-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端知识/" itemprop="url" rel="index"><span itemprop="name">前端知识</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果你对JVectorMap不太了解，请先阅读《开源JS地图插件JVectorMap介绍》。WorldMap非常重要的类，它可以创建地图、画路径、绑定事件。</p>
<h2 id="WorldMap构造方法参数"><a href="#WorldMap构造方法参数" class="headerlink" title="WorldMap构造方法参数"></a>WorldMap构造方法参数</h2><p>名称</p>
<p>类型</p>
<p>描述</p>
<p>map</p>
<p>String</p>
<p>地图数据的名称。格式一般为：<code>territory_proj_lang</code>，<code>territory</code> 为 <code>ISO 3166</code> 标准定义的国家代码，<code>proj</code> 为投影名称，<code>lang</code>为国家或地区语言。</p>
<p>backgroundColor</p>
<p>String</p>
<p>地图背景色。</p>
<p>zoomOnScroll</p>
<p>Boolean</p>
<p>如果为true可以使用鼠标滚动缩放，默认为true。</p>
<p>zoomMax</p>
<p>Number</p>
<p>表示地图可以缩放的最大比例，默认为8。</p>
<p>zoomMin</p>
<p>Number</p>
<p>表示地图可以缩放的最小比例，默认为1。</p>
<p>zoomStep</p>
<p>Number</p>
<p>表示使用+ / -按钮缩放地图的倍数，默认是1.6。</p>
<p>regionsSelectable</p>
<p>Boolean</p>
<p>如果设置为true，区域可以被选择，默认为false。</p>
<p>regionsSelectableOne</p>
<p>Boolean</p>
<p>同时只可以选择一个区域，默认为false。</p>
<p>markersSelectable</p>
<p>Boolean</p>
<p>标记是否可选，默认为false；</p>
<p>markersSelectableOne</p>
<p>Boolean</p>
<p>同时只可以选择一个标记，默认为false。</p>
<p>regionStyle</p>
<p>Object</p>
<p>为地图区域设置样式。每个区域或者标记有四种状态：<code>initial</code> (默认状态), <code>hover</code> (鼠标经过区域或者标记时), <code>selected</code> (区域或标记被选择时), <code>selectedHover</code> (区域或标记被选择时鼠标经过)。每个状态都可以设置样式，默认参数值为：{initial:{fill:’white’,”fill-opacity”:1,stroke:’none’,”stroke-width”:0,”stroke-opacity”:1},hover:{“fill-opacity”:0.8},selected:{fill:’yellow’},selectedHover:{}}</p>
<p>markerStyle</p>
<p>Object</p>
<p>给标记设置样式。其中r代表圆的半径，默认参数值为： {initial:{fill:’grey’,stroke:’#505050’,”fill-opacity”:1,”stroke-width”:1,”stroke-opacity”:1,r:5},hover:{stroke:’black’,”stroke-width”:2},selected:{fill:’blue’},selectedHover:{}}</p>
<p>markers</p>
<p>Object | Array</p>
<p>地图初始化时设置标记。如果值为数组，标记的codes将会使用数组索引作为字符串表示。一般每组标记都会包含<code>latLng</code>(数字数组，纬经度), <code>name</code> (标记上现实的名字) 和样式内容。</p>
<p>series</p>
<p>Object</p>
<p>这个对象包含 <code>markers</code> 和 <code>regions</code> 键值，请参看<a href="http://www.u396.com/?p=116" title="JVectorMap API之DataSeries" target="_blank" rel="noopener">DataSeries</a>。</p>
<p>focusOn</p>
<p>Object | String</p>
<p>这个参数用来设置地图<code>viewport</code>的初始<code>position</code> 和 <code>scale</code>。例如设置焦点为地图中心并且放大2倍可以使用下面的值： {x: 0.5,y: 0.5,scale: 2}</p>
<p>selectedRegions</p>
<p>Array | Object | String</p>
<p>设置初始选择区域</p>
<p>selectedMarkers</p>
<p>Array | Object | String</p>
<p>设置初始选择标记</p>
<p>onRegionLabelShow</p>
<p>Function</p>
<p>(Event e, Object label, String code)将在区域标签将被显示前调用。</p>
<p>onRegionOver</p>
<p>Function</p>
<p>(Event e, String code)鼠标悬停在区域标签上方时调用。</p>
<p>onRegionOut</p>
<p>Function</p>
<p>(Event e, String code)鼠标从在区域标签移走时调用。</p>
<p>onRegionClick</p>
<p>Function</p>
<p>(Event e, String code)将在区域标签将被点击时调用。</p>
<p>onRegionSelected</p>
<p>Function</p>
<p>(Event e, String code, Boolean isSelected, Array selectedRegions) 区域被选择时调用。回调方法里面的参数<code>isSelected</code>表示区域是否被选择。参数<code>selectedRegions</code>被选择区域的代码。</p>
<p>onMarkerLabelShow</p>
<p>Function</p>
<p>(Event e, Object label, String code) 标记被展示前调用。</p>
<p>onMarkerOver</p>
<p>Function</p>
<p>(Event e, String code)鼠标在标记上面悬停时触发。</p>
<p>onMarkerOut</p>
<p>Function</p>
<p>(Event e, String code)鼠标从标记上方移出时触发。</p>
<p>onMarkerClick</p>
<p>Function</p>
<p>(Event e, String code)点击标记时触发。</p>
<p>onMarkerSelected</p>
<p>Function</p>
<p>(Event e, String code, Boolean isSelected, Array selectedMarkers) 标记被选择时触发。回调方法里面的参数<code>isSelected</code>表示区域是否被选择。参数<code>selectedRegions</code>被选择区域的代码。</p>
<p>onViewportChange</p>
<p>Function</p>
<p>(Event e, Number scale)地图的窗口改变时触发(地图移动或缩放视图)。</p>
<h2 id="WorldMap提供的方法"><a href="#WorldMap提供的方法" class="headerlink" title="WorldMap提供的方法"></a>WorldMap提供的方法</h2><ul>
<li><h3 id="addMarker"><a href="#addMarker" class="headerlink" title="addMarker"></a>addMarker</h3></li>
</ul>
<p>向地图中添加一个标记。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>key</p>
<p>String</p>
<p>标记的唯一Code。</p>
<p>marker</p>
<p>Object</p>
<p>标记的配置参数。</p>
<p>seriesData</p>
<p>Array</p>
<p>向数据序列增加的值。</p>
<ul>
<li><h3 id="addMarkers"><a href="#addMarkers" class="headerlink" title="addMarkers"></a>addMarkers</h3></li>
</ul>
<p>向地图中添加一个或者多个标记。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>markers</p>
<p>Object | Array</p>
<p>向地图增加的标记列表。</p>
<p>seriesData</p>
<p>Array</p>
<p>向数据序列中增加的值。</p>
<ul>
<li><h3 id="clearSelectedMarkers"><a href="#clearSelectedMarkers" class="headerlink" title="clearSelectedMarkers"></a>clearSelectedMarkers</h3></li>
</ul>
<p>将当前选择状态的标记置为未选择状态。</p>
<ul>
<li><h3 id="clearSelectedRegions"><a href="#clearSelectedRegions" class="headerlink" title="clearSelectedRegions"></a>clearSelectedRegions</h3></li>
</ul>
<p>将当前选择状态的区域置为未选择状态。</p>
<ul>
<li><h3 id="getMapObject"><a href="#getMapObject" class="headerlink" title="getMapObject"></a>getMapObject</h3></li>
</ul>
<p>返回WorldMap实例。作为jQuery插件被实例化非常有用，返回类型为WorldMap。</p>
<ul>
<li><h3 id="getRegionName"><a href="#getRegionName" class="headerlink" title="getRegionName"></a>getRegionName</h3></li>
</ul>
<p>根据区域code返回名称。返回类型为String。</p>
<ul>
<li><h3 id="getSelectedMarkers"><a href="#getSelectedMarkers" class="headerlink" title="getSelectedMarkers"></a>getSelectedMarkers</h3></li>
</ul>
<p>返回被选择的标记。类型为Array。</p>
<ul>
<li><h3 id="getSelectedRegions"><a href="#getSelectedRegions" class="headerlink" title="getSelectedRegions"></a>getSelectedRegions</h3></li>
</ul>
<p>返回被选择的区域。类型为Array。</p>
<ul>
<li><h3 id="latLngToPoint"><a href="#latLngToPoint" class="headerlink" title="latLngToPoint"></a>latLngToPoint</h3></li>
</ul>
<p>将经纬度坐标转化为像素坐标。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>lat</p>
<p>Number</p>
<p>点的纬度坐标值。</p>
<p>lng</p>
<p>Number</p>
<p>点的经度坐标值。</p>
<ul>
<li><h3 id="pointToLatLng"><a href="#pointToLatLng" class="headerlink" title="pointToLatLng"></a>pointToLatLng</h3></li>
</ul>
<p>将笛卡尔坐标转化为经纬度坐标。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>x</p>
<p>Number</p>
<p>地图中点的X坐标值。</p>
<p>y</p>
<p>Number</p>
<p>地图中点的Y坐标值。</p>
<ul>
<li><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3></li>
</ul>
<p>删除地图以及绑定的事件。</p>
<ul>
<li><h3 id="removeAllMarkers"><a href="#removeAllMarkers" class="headerlink" title="removeAllMarkers"></a>removeAllMarkers</h3></li>
</ul>
<p>从地图中删除所有标记。</p>
<ul>
<li><h3 id="removeMarkers"><a href="#removeMarkers" class="headerlink" title="removeMarkers"></a>removeMarkers</h3></li>
</ul>
<p>从地图中删除指定的标记。</p>
<p>名称</p>
<p>类别</p>
<p>描述</p>
<p>markers</p>
<p>Array</p>
<p>将要被移出的标记code列表。</p>
<ul>
<li><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3></li>
</ul>
<p>重置地图为初始化状态。</p>
<ul>
<li><h3 id="setBackgroundColor"><a href="#setBackgroundColor" class="headerlink" title="setBackgroundColor"></a>setBackgroundColor</h3></li>
</ul>
<p>设置地图的背景色。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>backgroundColor</p>
<p>String</p>
<p>CSS格式的背景颜色值。</p>
<ul>
<li><h3 id="setFocus"><a href="#setFocus" class="headerlink" title="setFocus"></a>setFocus</h3></li>
</ul>
<p>设置地图视窗为指定的点以及指定缩放级别。点和缩放级别有两种定义方式：将一些区域的code设置为焦点或者一个中心点和级别设置为数字。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>scale|regionCode|regionCodes</p>
<p>Number | String | Array</p>
<p>如果方法中的第一个参数是字符串或者数组，则为区域代码列表，视图中将会展示这些区域。否则第一个参数为数字，视图将会被设置为提供的scale。</p>
<p>centerX</p>
<p>Number</p>
<p>视图中心点水平坐标，值范围（0-1）。</p>
<p>centerY</p>
<p>Number</p>
<p>视图中心点垂直坐标，值范围（0-1）。</p>
<ul>
<li><h3 id="setSelectedMarkers"><a href="#setSelectedMarkers" class="headerlink" title="setSelectedMarkers"></a>setSelectedMarkers</h3></li>
</ul>
<p>设置或者移除标记的选择状态。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>keys</p>
<p>String | Array | Object</p>
<p>如果为数组或者字符串，这些值代表的标记将会被选择。如果为对象，其键值代表标记的code，状态会被改变。选择状态将会被置为ture，否则将会移除。</p>
<ul>
<li><h3 id="setSelectedRegions"><a href="#setSelectedRegions" class="headerlink" title="setSelectedRegions"></a>setSelectedRegions</h3></li>
</ul>
<p>设置或者移除区域的选择状态。</p>
<p>名称</p>
<p>类型</p>
<p>描述</p>
<p>keys</p>
<p>String | Array | Object</p>
<p>如果为数组或者字符串，这些值代表的区域将会被选择。如果为对象，其键值代表区域的code，状态会被改变。选择状态将会被置为ture，否则将会移除。</p>
<ul>
<li><h3 id="setSize"><a href="#setSize" class="headerlink" title="setSize"></a>setSize</h3></li>
</ul>
<p>将地图和容器大小设置为一致。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/03/08/vue-webpack-e5-bc-95-e5-85-a5jquery/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/08/vue-webpack-e5-bc-95-e5-85-a5jquery/" class="post-title-link" itemprop="url">vue webpack 引入jquery</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-08 10:38:53" itemprop="dateCreated datePublished" datetime="2017-03-08T10:38:53+08:00">2017-03-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在vue-cli 生成的工程中引入了jquery，记录一下。(模板用的webpack) 首先在项目下执行 cnpm install jquery -D 下载安装jquery,下载完可以在package.json看见devDependencies中会有jquery版本为最新的。 在webpack.base.conf.js里加入 var webpack = require(“webpack”) 在module.exports的最后加入</p>
<p>plugins: [<br>    new webpack.optimize.CommonsChunkPlugin(‘common.js’),<br>    new webpack.ProvidePlugin({<br>    jQuery: “jquery”,<br>    $: “jquery”<br>})<br>]</p>
<p>然后一定要重新跑下 在main.js 引入就ok了import $ from ‘jquery’；</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/03/01/js-e5-88-a4-e6-96-ad-e9-a1-b5-e9-9d-a2-e6-98-af-e5-90-a6-e5-b7-b2-e7-bb-8f-e6-bb-9a-e5-8a-a8-e5-88-b0-e5-ba-95-e9-83-a8/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/03/01/js-e5-88-a4-e6-96-ad-e9-a1-b5-e9-9d-a2-e6-98-af-e5-90-a6-e5-b7-b2-e7-bb-8f-e6-bb-9a-e5-8a-a8-e5-88-b0-e5-ba-95-e9-83-a8/" class="post-title-link" itemprop="url">js判断页面是否已经滚动到底部</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-01 17:50:32" itemprop="dateCreated datePublished" datetime="2017-03-01T17:50:32+08:00">2017-03-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端知识/" itemprop="url" rel="index"><span itemprop="name">前端知识</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>判断滚动条到底部，需要用到DOM的三个属性值，即scrollTop、clientHeight、scrollHeight。</p>
<p>scrollTop为滚动条在Y轴上的滚动距离。</p>
<p>clientHeight为内容可视区域的高度。</p>
<p>scrollHeight为内容可视区域的高度加上溢出（滚动）的距离。</p>
<p>从这个三个属性的介绍就可以看出来，滚动条到底部的条件即为scrollTop + clientHeight == scrollHeight。</p>
<p>代码如下（兼容不同的浏览器）。</p>
<p>//滚动条在Y轴上的滚动距离</p>
<p>function getScrollTop(){<br>　　var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0;<br>　　if(document.body){<br>　　　　bodyScrollTop = document.body.scrollTop;<br>　　}<br>　　if(document.documentElement){<br>　　　　documentScrollTop = document.documentElement.scrollTop;<br>　　}<br>　　scrollTop = (bodyScrollTop - documentScrollTop &gt; 0) ? bodyScrollTop : documentScrollTop;<br>　　return scrollTop;<br>}</p>
<p>//文档的总高度</p>
<p>function getScrollHeight(){<br>　　var scrollHeight = 0, bodyScrollHeight = 0, documentScrollHeight = 0;<br>　　if(document.body){<br>　　　　bodyScrollHeight = document.body.scrollHeight;<br>　　}<br>　　if(document.documentElement){<br>　　　　documentScrollHeight = document.documentElement.scrollHeight;<br>　　}<br>　　scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; 0) ? bodyScrollHeight : documentScrollHeight;<br>　　return scrollHeight;<br>}</p>
<p>//浏览器视口的高度</p>
<p>function getWindowHeight(){<br>　　var windowHeight = 0;<br>　　if(document.compatMode == “CSS1Compat”){<br>　　　　windowHeight = document.documentElement.clientHeight;<br>　　}else{<br>　　　　windowHeight = document.body.clientHeight;<br>　　}<br>　　return windowHeight;<br>}</p>
<p>window.onscroll = function(){<br>　　if(getScrollTop() + getWindowHeight() == getScrollHeight()){<br>　　　　alert(“已经到最底部了！!”);<br>　　}<br>};</p>
<p>如果用jquery来实现的话就更简单了，</p>
<p>$(window).scroll(function(){<br>　　var scrollTop = $(this).scrollTop();<br>　　var scrollHeight = $(document).height();<br>　　var windowHeight = $(this).height();<br>　　if(scrollTop + windowHeight == scrollHeight){<br>　　　　alert(“已经到最底部了！”);<br>　　}<br>});</p>
<p>如果要判断在某一个元素中的滚动条是否到底部，根据类似的思想，将document.body换成特定的元素即可，获取scrollTop和scrollHeight的方式是一样的，但是获取元素可见高度需要用到offsetHeight属性，直接依葫芦画瓢即可。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/02/28/vue-webpack-e9-a1-b9-e7-9b-ae-e4-b8-ad-e8-af-b7-e6-b1-82-e8-b7-a8-e5-9f-9f-e7-9a-84-e9-97-ae-e9-a2-98/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/28/vue-webpack-e9-a1-b9-e7-9b-ae-e4-b8-ad-e8-af-b7-e6-b1-82-e8-b7-a8-e5-9f-9f-e7-9a-84-e9-97-ae-e9-a2-98/" class="post-title-link" itemprop="url">Vue-webpack项目中请求跨域的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-28 16:43:45" itemprop="dateCreated datePublished" datetime="2017-02-28T16:43:45+08:00">2017-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>只需要在config/index.js下面的dev配置上proxyTable</p>
<p>  proxyTable: {<br>      // proxy all requests starting with /proxy to jsonplaceholder<br>      ‘/api’: {<br>        target: ‘<a href="https://api.re.net&#39;" target="_blank" rel="noopener">https://api.re.net&#39;</a>,<br>        changeOrigin: true,<br>        pathRewrite: {<br>          ‘^/api’: ‘’<br>        }<br>      }</p>
<p>这里的样配置 /api/list 请求会被代理到 api.re.net/list     proxy文档地址：<a href="https://vuejs-templates.github.io/webpack/proxy.html" target="_blank" rel="noopener">https://vuejs-templates.github.io/webpack/proxy.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/02/28/servlet-e7-ba-bf-e7-a8-8b-e5-ae-89-e5-85-a8-e6-80-a7-e9-97-ae-e9-a2-98/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/28/servlet-e7-ba-bf-e7-a8-8b-e5-ae-89-e5-85-a8-e6-80-a7-e9-97-ae-e9-a2-98/" class="post-title-link" itemprop="url">Servlet线程安全性问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-28 11:29:43" itemprop="dateCreated datePublished" datetime="2017-02-28T11:29:43+08:00">2017-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后端开发/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>　摘 要</strong>：介绍了Servlet多线程机制，通过一个实例并结合Java 的内存模型说明引起Servlet线程不安全的原因，给出了保证Servlet线程安全的三种解决方案，并说明三种方案在实际开发中的取舍。 Servlet/JSP技术和ASP、PHP等相比，由于其多线程运行而具有很高的执行效率。由于Servlet/JSP默认是以多线程模式执行的，所 以，在编写代码时需要非常细致地考虑多线程的安全性问题。然而，很多人编写Servlet/JSP程序时并没有注意到多线程安全性的问题，这往往造成编写 的程序在少量用户访问时没有任何问题，而在并发用户上升到一定值时，就会经常出现一些莫明其妙的问题。 <strong>Servlet的多线程机制</strong> Servlet体系结构是建立在Java多线程机制之上的，它的生命周期是由Web容器负责的。当客户端第一次请求某个Servlet时，Servlet容器将会根据web.xml配置文件实例化这个Servlet类。当有新的客户端请求该Servlet时，一般不会再实例化该Servlet类，也就是有多个线程在使用这个实例。Servlet容器会自动使用线程池等技术来支持系统的运行，如图1所示。 <img src="http://zhongmin.me/wp-content/uploads/2017/02/2012090713422194.png" alt> 这样，当两个或多个线程同时访问同一个Servlet时，可能会发生多个线程同时访问同一资源的情况，数据可能会变得不一致。所以在用Servlet构建的Web应用时如果不注意线程安全的问题，会使所写的Servlet程序有难以发现的错误。 <strong>Servlet的线程安全问题 </strong> Servlet的线程安全问题主要是由于实例变量使用不当而引起的，这里以一个现实的例子来说明。</p>
<p> 1 public class ConcurrentTest extends HttpServlet {<br> 2     PrintWriter output;<br> 3     @Override<br> 4     protected void service(HttpServletRequest request, HttpServletResponse response)<br> 5             throws ServletException, IOException {<br> 6         String  username;<br> 7         response.setContentType(“text/html;charset=gb2312”);<br> 8         username=request.getParameter(“username”);<br> 9         output=response.getWriter();<br>10         try {<br>11             //为了突出并发问题，在这设置一个延时<br>12             Thread.sleep(5000);<br>13             output.println(“用户名:”+username+”<br>“);<br>14         } catch (Exception e) {<br>15             e.printStackTrace();<br>16         }<br>17     }<br>18 }</p>
<p>该Servlet中定义了一个实例变量output，在service方法将其赋值为用户的输出。当一个用户访问该Servlet时，程序会正常的运行，但当多个用户并发访问时，就可能会出现其它用户的信息显示在另外一些用户的浏览器上的问题。这是一个严重的问题。为了突出并发问题，便于测试、观察，我们在回显用户信息时执行了一个延时的操作。假设已在web.xml配置文件中注册了该Servlet，现有两个用户a和b同时访问该Servlet（可以启动两个IE浏览器，或者在两台机器上同时访问）,即同时在浏览器中输入：</p>
<p>a： <a href="http://localhost:8080/ServletTest/ConcurrentTest?Username=a" target="_blank" rel="noopener">http://localhost:8080/ServletTest/ConcurrentTest?Username=a</a> b： <a href="http://localhost:8080/ServletTest/ConcurrentTest?Username=b" target="_blank" rel="noopener">http://localhost:8080/ServletTest/ConcurrentTest?Username=b</a> 如果用户b比用户a回车的时间稍慢一点，将得到如图2所示的输出： <img src="http://zhongmin.me/wp-content/uploads/2017/02/2012090713484742.png" alt></p>
<p>图2 a用户和b用户的浏览器输出</p>
<p>从图2中可以看到，Web服务器启动了两个线程分别处理来自用户a和用户b的请求，但是在用户a的浏览器上却得到一个空白的屏幕，用户a的信息显示在用户b的浏览器上。该Servlet存在线程不安全问题。下面我们就从分析该实例的内存模型入手,观察不同时刻实例变量output的值来分析使该Servlet线程不安全的原因。 Java的内存模型JMM（Java Memory Model）JMM主要是为了规定了线程和内存之间的一些关系。<strong>根据JMM的设计，系统存在一个主内存(Main Memory)，Java中所有实例变量都储存在主存中，对于所有线程都是共享的。每条线程都有自己的工作内存(Working Memory)，工作内存由缓存和堆栈两部分组成，缓存中保存的是主存中变量的拷贝，缓存可能并不总和主存同步，也就是缓存中变量的修改可能没有立刻写到主存中；堆栈中保存的是线程的局部变量，线程之间无法相互直接访问堆栈中的变量。</strong>根据JMM，我们可以将论文中所讨论的Servlet实例的内存模型抽象为图3所示的模型。 <img src="http://zhongmin.me/wp-content/uploads/2017/02/2012090713513288.png" alt> 下面根据图3所示的内存模型，来分析当用户a和b的线程（简称为a线程、b线程）并发执行时，Servlet实例中所涉及变量的变化情况及线程的执行情况，如图4所示。 <img src="http://zhongmin.me/wp-content/uploads/2017/02/2012090713520185.png" alt> 从图4中可以清楚的看到，由于b线程对实例变量output的修改覆盖了a线程对实例变量output的修改，从而导致了用户a的信息显示在了用户b的浏览器上。如果在a线程执行输出语句时，b线程对output的修改还没有刷新到主存，那么将不会出现图2所示的输出结果，因此这只是一种偶然现象，但这更增加了程序潜在的危险性。 <strong>设计线程安全的Servlet</strong> 通过上面的分析，我们知道了<strong>实例变量不正确的使用是造成Servlet线程不安全的主要原因。</strong>下面针对该问题给出了三种解决方案并对方案的选取给出了一些参考性的建议。 1、实现 SingleThreadModel 接口 该接口指定了系统如何处理对同一个Servlet的调用。如果一个Servlet被这个接口指定,那么在这个Servlet中的service方法将不会有两个线程被同时执行，当然也就不存在线程安全的问题。这种方法只要将前面的Concurrent Test类的类头定义更改为：</p>
<p>1 public class ConcurrentTest extends HttpServlet implements SingleThreadModel  {<br>2       …  …<br>3 }</p>
<p>javax.servlet.SingleThreadModel API及其翻译 Ensures that servlets handle only one request at a time. This interface has no methods. <strong>确保servlet每次只处理一项请求。接口不含方法。</strong> If a servlet implements this interface, you are <em>guaranteed</em> that no two threads will execute concurrently in the servlet’s <code>service</code> method. The servlet container can make this guarantee by synchronizing access to a single instance of the servlet, or by maintaining a pool of servlet instances and dispatching each new request to a free servlet. <strong>如果servlet实现了该接口，会确保不会有两个线程同时执行servlet的service方法。 servlet容器通过同步化访问servlet的单实例来保证，也可以通过维持servlet的实例池，对于新的请求会分配给一个空闲的servlet。</strong> Note that SingleThreadModel does not solve all thread safety issues. For example, session attributes and static variables can still be accessed by multiple requests on multiple threads at the same time, even when SingleThreadModel servlets are used. It is recommended that a developer take other means to resolve those issues instead of implementing this interface, such as avoiding the usage of an instance variable or synchronizing the block of the code accessing those resources. This interface is deprecated in Servlet API version 2.4. <strong>注意：SingleThreadModel不会解决所有的线程安全隐患。</strong> 例如，会话属性和静态变量仍然可以被多线程的多请求同时访问，即便使用了SingleThreadModel servlet。<strong>建议开发人员应当采取其他手段来解决这些问题，而不是实现该接口，比如 避免实例变量的使用或者在访问资源时同步代码块。该接口在Servlet　API 2.4中将不推荐使用。</strong> 2、同步对共享数据的操作 使用synchronized 关键字能保证一次只有一个线程可以访问被保护的区段，在本论文中的Servlet可以通过同步块操作来保证线程的安全。同步后的代码如下：</p>
<p> 1 public class ConcurrentTest extends HttpServlet {<br> 2     PrintWriter output;<br> 3     @Override<br> 4     protected void service(HttpServletRequest request, HttpServletResponse response)<br> 5             throws ServletException, IOException {<br> 6         String  username;<br> 7         response.setContentType(“text/html;charset=gb2312”);<br> 8         username=request.getParameter(“username”);<br> 9         synchronized(this){<br>10             output=response.getWriter();<br>11             try {<br>12                 //为了突出并发问题，在这设置一个延时<br>13                 Thread.sleep(5000);<br>14                 output.println(“用户名:”+username+”<br>“);<br>15             } catch (Exception e) {<br>16                 e.printStackTrace();<br>17             }<br>18         }<br>19     }<br>20 }</p>
<p>　　3、避免使用实例变量</p>
<p>本实例中的线程安全问题是由实例变量造成的，只要在Servlet里面的任何方法里面都不使用实例变量，那么该Servlet就是线程安全的。 修正上面的Servlet代码，将实例变量改为局部变量实现同样的功能，代码如下：</p>
<p> 1 public class ConcurrentTest extends HttpServlet {<br> 2     @Override<br> 3     protected void service(HttpServletRequest request, HttpServletResponse response)<br> 4             throws ServletException, IOException {<br> 5         PrintWriter output;<br> 6         String username;<br> 7         response.setContentType(“text/html;charset=gb2312”);<br> 8         username=request.getParameter(“username”);<br> 9         synchronized(this){<br>10             output=response.getWriter();<br>11             try {<br>12                 //为了突出并发问题，在这设置一个延时<br>13                 Thread.sleep(5000);<br>14                 output.println(“用户名:”+username+”<br>“);<br>15             } catch (Exception e) {<br>16                 e.printStackTrace();<br>17             }<br>18         }<br>19     }<br>20 }</p>
<pre><code>对上面的三种方法进行测试，可以表明用它们都能设计出线程安全的Servlet程序。但是，如果一个Servlet实现了SingleThreadModel接口，Servlet引擎将为每个新的请求创建一个单独的Servlet实例，这将引起大量的系统开销。SingleThreadModel在Servlet2.4中已不再提倡使用；同样如果在程序中使用同步来保护要使用的共享的数据，也会使系统的性能大大下降。这是因为被同步的代码块在同一时刻只能有一个线程执行它，使得其同时处理客户请求的吞吐量降低，而且很多客户处于阻塞状态。另外为保证主存内容和线程的工作内存中的数据的一致性，要频繁地刷新缓存,这也会大大地影响系统的性能。所以在实际的开发中也应避免或最小化 Servlet 中的同步代码；在Serlet中避免使用实例变量是保证Servlet线程安全的最佳选择。从Java 内存模型也可以知道，方法中的临时变量是在栈上分配空间，而且每个线程都有自己私有的栈空间，所以它们不会影响线程的安全。
</code></pre><p><strong>小结</strong> Servlet的线程安全问题只有在大量的并发访问时才会显现出来，并且很难发现，因此在编写Servlet程序时要特别注意。线程安全问题主要是由实例变量造成的,因此在Servlet中应避免使用实例变量。<strong>如果应用程序设计无法避免使用实例变量，那么使用同步来保护要使用的实例变量，但为保证系统的最佳性能，应该同步可用性最小的代码路径。</strong></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/02/24/vue2-0-e8-ae-b0-e5-bd-95-e8-b7-af-e7-94-b1-e4-b8-8e-e7-bb-84-e4-bb-b6-e8-b8-a9-e8-bf-87-e7-9a-84-e5-9d-91/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/24/vue2-0-e8-ae-b0-e5-bd-95-e8-b7-af-e7-94-b1-e4-b8-8e-e7-bb-84-e4-bb-b6-e8-b8-a9-e8-bf-87-e7-9a-84-e5-9d-91/" class="post-title-link" itemprop="url">Vue2.0 记录路由与组件踩过的坑</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-24 14:05:10" itemprop="dateCreated datePublished" datetime="2017-02-24T14:05:10+08:00">2017-02-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>路由与组件踩过的坑: 1.在路由引入组件前，需要先队组件进行定义，即组件的定义在路由前面，最后再到vue示例； 2.如果在实例中用到组件需要挂载组件，通过render: h =&gt; h(app);挂载，括号中的是组件名称, 关于 render: h =&gt; h(app) 函数, 箭头函数是ES6语法；</p>
<p>//ES6<br>h =&gt; h(app)</p>
<p>//ES5<br>(function (h) {<br>return h(App);<br>});</p>
<p>render: h =&gt; h(app)是Vue 2.0新增的函数，可以直接给绑定节点渲染一个vue组件， 一般可以直接这样给实例绑定一个vue组件，这样做不需要再页面中填入组件标记了</p>
<p>new Vue({<br>  el: ‘#app’,<br>  render: h =&gt; h(app)<br>});</p>
<p>不用render也可以使用</p>
<p>new Vue({<br>  el: ‘#app’,<br>  components: { App }<br>});</p>
<p>同时页面中需要写入组件标记</p>
<div id="app"><br>  <app></app><br></div>

<p>3. 在官网中创建vueRouter实例的时候给出的示例:</p>
<p>const router = new VueRouter({<br>   routes // （缩写）相当于 routes: routes<br>});</p>
<p>自己在定义路由时候将名称定义成了 routers,然后也采用了缩写写入了routers, 这时候vue不会报错，路由也没有生效，查了好久才发现这个问题，采用缩写的话必须要与属性名保持一致。 后面的挂载路由是也是同理；也可以不采用缩写方法，少偷懒也少踩点坑。 4.路由redirect 的配置，redirect配置在后面, 刚开始的时候不小心将 <code>{path:&quot;*&quot;,redirect:&quot;/app&quot;}</code> 配置在了路由第一个位置，vue会报栈溢出的错误。 5.golbal bus 只能在同一个路由下不同组件进行通讯，在不同路由之间会出现问题，比如A组件在跳往B组件的时候，通过$.emit 发送了一条消息，这时候B该如何接收？因为在发消息的时候B组件还没有创建，所以B组件无法监听A组件发出的消息进行回调。 6.在router-link中绑定方法时会失效,比如@click,@mouseover,后来发现根据Vue2.0官方文档关于父子组件通讯的原则，父组件通过prop传递数据给子组件，子组件触发事件给父组件。但父组件想在子组件上监听自己的click的话，需要加上<code>native</code>修饰符。所以如果在想要在router-link上添加事件的话需要@click.native这样写</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/02/20/eslint-e8-a7-84-e5-88-99-e8-af-b4-e6-98-8e/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/20/eslint-e8-a7-84-e5-88-99-e8-af-b4-e6-98-8e/" class="post-title-link" itemprop="url">Eslint 规则说明</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-20 11:07:30" itemprop="dateCreated datePublished" datetime="2017-02-20T11:07:30+08:00">2017-02-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端知识/" itemprop="url" rel="index"><span itemprop="name">前端知识</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“no-alert”: 0,//禁止使用alert confirm prompt<br>“no-array-constructor”: 2,//禁止使用数组构造器<br>“no-bitwise”: 0,//禁止使用按位运算符<br>“no-caller”: 1,//禁止使用arguments.caller或arguments.callee<br>“no-catch-shadow”: 2,//禁止catch子句参数与外部作用域变量同名<br>“no-class-assign”: 2,//禁止给类赋值<br>“no-cond-assign”: 2,//禁止在条件表达式中使用赋值语句<br>“no-console”: 2,//禁止使用console<br>“no-const-assign”: 2,//禁止修改const声明的变量<br>“no-constant-condition”: 2,//禁止在条件中使用常量表达式 if(true) if(1)<br>“no-continue”: 0,//禁止使用continue<br>“no-control-regex”: 2,//禁止在正则表达式中使用控制字符<br>“no-debugger”: 2,//禁止使用debugger<br>“no-delete-var”: 2,//不能对var声明的变量使用delete操作符<br>“no-div-regex”: 1,//不能使用看起来像除法的正则表达式/=foo/<br>“no-dupe-keys”: 2,//在创建对象字面量时不允许键重复 {a:1,a:1}<br>“no-dupe-args”: 2,//函数参数不能重复<br>“no-duplicate-case”: 2,//switch中的case标签不能重复<br>“no-else-return”: 2,//如果if语句里面有return,后面不能跟else语句<br>“no-empty”: 2,//块语句中的内容不能为空<br>“no-empty-character-class”: 2,//正则表达式中的[]内容不能为空<br>“no-empty-label”: 2,//禁止使用空label<br>“no-eq-null”: 2,//禁止对null使用==或!=运算符<br>“no-eval”: 1,//禁止使用eval<br>“no-ex-assign”: 2,//禁止给catch语句中的异常参数赋值<br>“no-extend-native”: 2,//禁止扩展native对象<br>“no-extra-bind”: 2,//禁止不必要的函数绑定<br>“no-extra-boolean-cast”: 2,//禁止不必要的bool转换<br>“no-extra-parens”: 2,//禁止非必要的括号<br>“no-extra-semi”: 2,//禁止多余的冒号<br>“no-fallthrough”: 1,//禁止switch穿透<br>“no-floating-decimal”: 2,//禁止省略浮点数中的0 .5 3.<br>“no-func-assign”: 2,//禁止重复的函数声明<br>“no-implicit-coercion”: 1,//禁止隐式转换<br>“no-implied-eval”: 2,//禁止使用隐式eval<br>“no-inline-comments”: 0,//禁止行内备注<br>“no-inner-declarations”: [2, “functions”],//禁止在块语句中使用声明（变量或函数）<br>“no-invalid-regexp”: 2,//禁止无效的正则表达式<br>“no-invalid-this”: 2,//禁止无效的this，只能用在构造器，类，对象字面量<br>“no-irregular-whitespace”: 2,//不能有不规则的空格<br>“no-iterator”: 2,//禁止使用__iterator__ 属性<br>“no-label-var”: 2,//label名不能与var声明的变量名相同<br>“no-labels”: 2,//禁止标签声明<br>“no-lone-blocks”: 2,//禁止不必要的嵌套块<br>“no-lonely-if”: 2,//禁止else语句内只有if语句<br>“no-loop-func”: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）<br>“no-mixed-requires”: [0, false],//声明时不能混用声明类型<br>“no-mixed-spaces-and-tabs”: [2, false],//禁止混用tab和空格<br>“linebreak-style”: [0, “windows”],//换行风格<br>“no-multi-spaces”: 1,//不能用多余的空格<br>“no-multi-str”: 2,//字符串不能用\换行<br>“no-multiple-empty-lines”: [1, {“max”: 2}],//空行最多不能超过2行<br>“no-native-reassign”: 2,//不能重写native对象<br>“no-negated-in-lhs”: 2,//in 操作符的左边不能有!<br>“no-nested-ternary”: 0,//禁止使用嵌套的三目运算<br>“no-new”: 1,//禁止在使用new构造一个实例后不赋值<br>“no-new-func”: 1,//禁止使用new Function<br>“no-new-object”: 2,//禁止使用new Object()<br>“no-new-require”: 2,//禁止使用new require<br>“no-new-wrappers”: 2,//禁止使用new创建包装实例，new String new Boolean new Number<br>“no-obj-calls”: 2,//不能调用内置的全局对象，比如Math() JSON()<br>“no-octal”: 2,//禁止使用八进制数字<br>“no-octal-escape”: 2,//禁止使用八进制转义序列<br>“no-param-reassign”: 2,//禁止给参数重新赋值<br>“no-path-concat”: 0,//node中不能使用__dirname或__filename做路径拼接<br>“no-plusplus”: 0,//禁止使用++，–<br>“no-process-env”: 0,//禁止使用process.env<br>“no-process-exit”: 0,//禁止使用process.exit()<br>“no-proto”: 2,//禁止使用__proto__属性<br>“no-redeclare”: 2,//禁止重复声明变量<br>“no-regex-spaces”: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/<br>“no-restricted-modules”: 0,//如果禁用了指定模块，使用就会报错<br>“no-return-assign”: 1,//return 语句中不能有赋值表达式<br>“no-script-url”: 0,//禁止使用javascript:void(0)<br>“no-self-compare”: 2,//不能比较自身<br>“no-sequences”: 0,//禁止使用逗号运算符<br>“no-shadow”: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名<br>“no-shadow-restricted-names”: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用<br>“no-spaced-func”: 2,//函数调用时 函数名与()之间不能有空格<br>“no-sparse-arrays”: 2,//禁止稀疏数组， [1,,2]<br>“no-sync”: 0,//nodejs 禁止同步方法<br>“no-ternary”: 0,//禁止使用三目运算符<br>“no-trailing-spaces”: 1,//一行结束后面不要有空格<br>“no-this-before-super”: 0,//在调用super()之前不能使用this或super<br>“no-throw-literal”: 2,//禁止抛出字面量错误 throw “error”;<br>“no-undef”: 1,//不能有未定义的变量<br>“no-undef-init”: 2,//变量初始化时不能直接给它赋值为undefined<br>“no-undefined”: 2,//不能使用undefined<br>“no-unexpected-multiline”: 2,//避免多行表达式<br>“no-underscore-dangle”: 1,//标识符不能以_开头或结尾<br>“no-unneeded-ternary”: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;<br>“no-unreachable”: 2,//不能有无法执行的代码<br>“no-unused-expressions”: 2,//禁止无用的表达式<br>“no-unused-vars”: [2, {“vars”: “all”, “args”: “after-used”}],//不能有声明后未被使用的变量或参数<br>“no-use-before-define”: 2,//未定义前不能使用<br>“no-useless-call”: 2,//禁止不必要的call和apply<br>“no-void”: 2,//禁用void操作符<br>“no-var”: 0,//禁用var，用let和const代替<br>“no-warning-comments”: [1, { “terms”: [“todo”, “fixme”, “xxx”], “location”: “start” }],//不能有警告备注<br>“no-with”: 2,//禁用with</p>
<p>“array-bracket-spacing”: [2, “never”],//是否允许非空数组里面有多余的空格<br>“arrow-parens”: 0,//箭头函数用小括号括起来<br>“arrow-spacing”: 0,//=&gt;的前/后括号<br>“accessor-pairs”: 0,//在对象中使用getter/setter<br>“block-scoped-var”: 0,//块语句中使用var<br>“brace-style”: [1, “1tbs”],//大括号风格<br>“callback-return”: 1,//避免多次调用回调什么的<br>“camelcase”: 2,//强制驼峰法命名<br>“comma-dangle”: [2, “never”],//对象字面量项尾不能有逗号<br>“comma-spacing”: 0,//逗号前后的空格<br>“comma-style”: [2, “last”],//逗号风格，换行时在行首还是行尾<br>“complexity”: [0, 11],//循环复杂度<br>“computed-property-spacing”: [0, “never”],//是否允许计算后的键名什么的<br>“consistent-return”: 0,//return 后面是否允许省略<br>“consistent-this”: [2, “that”],//this别名<br>“constructor-super”: 0,//非派生类不能调用super，派生类必须调用super<br>“curly”: [2, “all”],//必须使用 if(){} 中的{}<br>“default-case”: 2,//switch语句最后必须有default<br>“dot-location”: 0,//对象访问符的位置，换行的时候在行首还是行尾<br>“dot-notation”: [0, { “allowKeywords”: true }],//避免不必要的方括号<br>“eol-last”: 0,//文件以单一的换行符结束<br>“eqeqeq”: 2,//必须使用全等<br>“func-names”: 0,//函数表达式必须有名字<br>“func-style”: [0, “declaration”],//函数风格，规定只能使用函数声明/函数表达式<br>“generator-star-spacing”: 0,//生成器函数*的前后空格<br>“guard-for-in”: 0,//for in循环要用if语句过滤<br>“handle-callback-err”: 0,//nodejs 处理错误<br>“id-length”: 0,//变量名长度<br>“indent”: [2, 4],//缩进风格<br>“init-declarations”: 0,//声明时必须赋初值<br>“key-spacing”: [0, { “beforeColon”: false, “afterColon”: true }],//对象字面量中冒号的前后空格<br>“lines-around-comment”: 0,//行前/行后备注<br>“max-depth”: [0, 4],//嵌套块深度<br>“max-len”: [0, 80, 4],//字符串最大长度<br>“max-nested-callbacks”: [0, 2],//回调嵌套深度<br>“max-params”: [0, 3],//函数最多只能有3个参数<br>“max-statements”: [0, 10],//函数内最多有几个声明<br>“new-cap”: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用<br>“new-parens”: 2,//new时必须加小括号<br>“newline-after-var”: 2,//变量声明后是否需要空一行<br>“object-curly-spacing”: [0, “never”],//大括号内是否允许不必要的空格<br>“object-shorthand”: 0,//强制对象字面量缩写语法<br>“one-var”: 1,//连续声明<br>“operator-assignment”: [0, “always”],//赋值运算符 += -=什么的<br>“operator-linebreak”: [2, “after”],//换行时运算符在行尾还是行首<br>“padded-blocks”: 0,//块语句内行首行尾是否要空行<br>“prefer-const”: 0,//首选const<br>“prefer-spread”: 0,//首选展开运算<br>“prefer-reflect”: 0,//首选Reflect的方法<br>“quotes”: [1, “single”],//引号类型 <code></code> “” ‘’<br>“quote-props”:[2, “always”],//对象字面量中的属性名是否强制双引号<br>“radix”: 2,//parseInt必须指定第二个参数<br>“id-match”: 0,//命名检测<br>“require-yield”: 0,//生成器函数必须有yield<br>“semi”: [2, “always”],//语句强制分号结尾<br>“semi-spacing”: [0, {“before”: false, “after”: true}],//分号前后空格<br>“sort-vars”: 0,//变量声明时排序<br>“space-after-keywords”: [0, “always”],//关键字后面是否要空一格<br>“space-before-blocks”: [0, “always”],//不以新行开始的块{前面要不要有空格<br>“space-before-function-paren”: [0, “always”],//函数定义时括号前面要不要有空格<br>“space-in-parens”: [0, “never”],//小括号里面要不要有空格<br>“space-infix-ops”: 0,//中缀操作符周围要不要有空格<br>“space-return-throw-case”: 2,//return throw case后面要不要加空格<br>“space-unary-ops”: [0, { “words”: true, “nonwords”: false }],//一元运算符的前/后要不要加空格<br>“spaced-comment”: 0,//注释风格要不要有空格什么的<br>“strict”: 2,//使用严格模式<br>“use-isnan”: 2,//禁止比较时使用NaN，只能用isNaN()<br>“valid-jsdoc”: 0,//jsdoc规则<br>“valid-typeof”: 2,//必须使用合法的typeof的值<br>“vars-on-top”: 2,//var必须放在作用域顶部<br>“wrap-iife”: [2, “inside”],//立即执行函数表达式的小括号风格<br>“wrap-regex”: 0,//正则表达式字面量用小括号包起来<br>“yoda”: [2, “never”]//禁止尤达条件</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/02/17/e6-b7-b1-e5-85-a5-e5-89-96-e6-9e-90-javascript-e7-9a-84-e6-b7-b1-e5-a4-8d-e5-88-b6/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/17/e6-b7-b1-e5-85-a5-e5-89-96-e6-9e-90-javascript-e7-9a-84-e6-b7-b1-e5-a4-8d-e5-88-b6/" class="post-title-link" itemprop="url">深入剖析 JavaScript 的深复制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-17 10:10:57" itemprop="dateCreated datePublished" datetime="2017-02-17T10:10:57+08:00">2017-02-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端知识/" itemprop="url" rel="index"><span itemprop="name">前端知识</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>浅拷贝和深拷贝也叫做浅克隆和深克隆，深浅主要针对的是对象的“深度”，常见的对象都是“浅”的，也就是对象里的属性就是单个的属性，而“深”的对象是指一个对象的属性就是一个对象，也就是对象里面套对象，就像嵌套函数一样。 为什么要使用深拷贝和浅拷贝？ 如果现有var obj={….}这个对象，想复制对象obj2，一贯的做法就是obj2=obj1，这时虽然obj2拥有了obj1的所有属性，但obj2却不是自由的，因为它的改动会影响到obj1，obj1的改动也会直接影响到obj2，这不是我们所希望的。所以要用到深拷贝和浅拷贝。 下面是一个简单的浅复制实现：</p>
<p>var obj = { a:1, arr: [2,3] };<br>var shadowObj = shadowCopy(obj);</p>
<p>function shadowCopy(src) {<br>  var dst = {};<br>  for (var prop in src) {<br>    if (src.hasOwnProperty(prop)) {<br>      dst[prop] = src[prop];<br>    }<br>  }<br>  return dst;<br>}</p>
<p>因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shadowObj.arr 指向同一块内存地址， 导致的结果就是：</p>
<p>shadowObj.arr[1] = 5;<br>obj.arr[1]   // = 5</p>
<p>而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法<strong>递归复制</strong>到新对象上。这就不会存在上面 obj 和 shadowObj 的 arr 属性指向同一个对象的问题。 不同的深复制实现方法和实现粒度有各自的优劣以及各自适合的应用场景，所以本文并不是在教大家改如何实现深复制，而是将一些在 JavaScript 中实现深复制所需要考虑的问题呈献给大家。我们首先从较为简单的 Underscore 开始：</p>
<h3 id="Underscore-——-clone"><a href="#Underscore-——-clone" class="headerlink" title="Underscore —— _.clone()"></a>Underscore —— _.clone()</h3><p>在 Underscore 中有这样一个方法：<code>_.clone()</code>，这个方法实际上是一种浅复制 (shallow-copy)，所有嵌套的对象和数组都是直接复制引用而并没有进行深复制。来看一下例子应该会更加直观：</p>
<p>var x = {<br>    a: 1,<br>    b: { z: 0 }<br>};</p>
<p>var y = _.clone(x);</p>
<p>y === x       // false<br>y.b === x.b   // true</p>
<p>x.b.z = 100;<br>y.b.z         // 100</p>
<p>让我们来看一下 <a href="https://github.com/jashkenas/underscore/blob/e4743ab712b8ab42ad4ccb48b155034d02394e4d/underscore.js#L1068" target="_blank" rel="noopener">Underscore 的源码</a>：</p>
<p>// Create a (shallow-cloned) duplicate of an object.<br><em>.clone = function(obj) {<br>  if (!</em>.isObject(obj)) return obj;<br>  return _.isArray(obj) ? obj.slice() : _.extend({}, obj);<br>};</p>
<p>如果目标对象是一个数组，则直接调用数组的<code>slice()</code>方法，否则就是用<code>_.extend()</code>方法。想必大家对<code>extend()</code>方法不会陌生，它的作用主要是将从第二个参数开始的所有对象，按键值逐个赋给第一个对象。而在 jQuery 中也有类似的方法。关于 Underscore 中的 <code>_.extend()</code> 方法的实现可以参考 <a href="https://github.com/jashkenas/underscore/blob/e4743ab712b8ab42ad4ccb48b155034d02394e4d/underscore.js#L1006" target="_blank" rel="noopener">underscore.js #L1006</a>。 Underscore 的 <code>clone()</code> 不能算作深复制，但它至少比直接赋值来得“深”一些，它创建了一个新的对象。另外，你也可以通过以下比较 tricky 的方法来完成<strong>单层</strong>嵌套的深复制：</p>
<p>var _ = require(‘underscore’);<br>var a = [{f: 1}, {f:5}, {f:10}];<br>var b = _.map(a, _.clone);       // &lt;—-<br>b[1].f = 55;<br>console.log(JSON.stringify(a));  // [{“f”:1},{“f”:5},{“f”:10}]</p>
<h3 id="jQuery-——-clone-extend"><a href="#jQuery-——-clone-extend" class="headerlink" title="jQuery —— $.clone() / $.extend()"></a>jQuery —— $.clone() / $.extend()</h3><p>在 jQuery 中也有这么一个叫 <code>$.clone()</code> 的方法，可是它并不是用于一般的 JS 对象的深复制，而是用于 DOM 对象。这不是这篇文章的重点，所以感兴趣的同学可以参考<a href="http://api.jquery.com/clone/" target="_blank" rel="noopener">jQuery的文档</a>。与 Underscore 类似，我们也是可以通过 <code>$.extend()</code> 方法来完成深复制。值得庆幸的是，我们在 jQuery 中可以通过添加一个参数来实现<strong>递归extend</strong>。调用<code>$.extend(true, {}, ...)</code>就可以实现深复制啦，参考下面的例子：</p>
<p>var x = {<br>    a: 1,<br>    b: { f: { g: 1 } },<br>    c: [ 1, 2, 3 ]<br>};</p>
<p>var y = $.extend({}, x),          //shallow copy<br>    z = $.extend(true, {}, x);    //deep copy</p>
<p>y.b.f === x.b.f       // true<br>z.b.f === x.b.f       // false</p>
<p>在 <a href="https://github.com/jquery/jquery/blob/1472290917f17af05e98007136096784f9051fab/src/core.js#L121" target="_blank" rel="noopener">jQuery的源码 - src/core.js #L121</a> 文件中我们可以找到<code>$.extend()</code>的实现，也是实现得比较简洁，而且不太依赖于 jQuery 的内置函数，稍作修改就能拿出来单独使用。</p>
<h3 id="lodash-——-clone-cloneDeep"><a href="#lodash-——-clone-cloneDeep" class="headerlink" title="lodash —— _.clone() / _.cloneDeep()"></a>lodash —— _.clone() / _.cloneDeep()</h3><p>在lodash中关于复制的方法有两个，分别是<code>_.clone()</code>和<code>_.cloneDeep()</code>。其中<code>_.clone(obj, true)</code>等价于<code>_.cloneDeep(obj)</code>。使用上，lodash和前两者并没有太大的区别，但看了源码会发现，Underscore 的实现只有30行左右，而 jQuery 也不过60多行。可 lodash 中与深复制相关的代码却有上百行</p>
<p>var $ = require(“jquery”),<br>    _ = require(“lodash”);</p>
<p>var arr = new Int16Array(5),<br>    obj = { a: arr },<br>    obj2;<br>arr[0] = 5;<br>arr[1] = 6;</p>
<p>// 1. jQuery<br>obj2 = $.extend(true, {}, obj);<br>console.log(obj2.a);                            // [5, 6, 0, 0, 0]<br>Object.prototype.toString.call(obj2);           // [object Int16Array]<br>obj2.a[0] = 100;<br>console.log(obj);                               // [100, 6, 0, 0, 0]</p>
<p>//此处jQuery不能正确处理Int16Array的深复制！！！</p>
<p>// 2. lodash<br>obj2 = _.cloneDeep(obj);<br>console.log(obj2.a);                            // [5, 6, 0, 0, 0]<br>Object.prototype.toString.call(arr2);           // [object Int16Array]<br>obj2.a[0] = 100;<br>console.log(obj);                               // [5, 6, 0, 0, 0]</p>
<p>通过上面这个例子可以初见端倪，jQuery 无法正确深复制 JSON 对象以外的对象，而我们可以从下面这段代码片段可以看出 lodash 花了大量的代码来实现 ES6 引入的大量新的标准对象。更厉害的是，lodash 针对<strong>存在环的对象</strong>的处理也是非常出色的。因此相较而言，lodash 在深复制上的行为反馈比前两个库好很多，是更拥抱未来的一个第三方库。</p>
<p>/** `Object#toString` result references. */<br>var argsTag = ‘[object Arguments]‘,<br>    arrayTag = ‘[object Array]‘,<br>    boolTag = ‘[object Boolean]‘,<br>    dateTag = ‘[object Date]‘,<br>    errorTag = ‘[object Error]‘,<br>    funcTag = ‘[object Function]‘,<br>    mapTag = ‘[object Map]‘,<br>    numberTag = ‘[object Number]‘,<br>    objectTag = ‘[object Object]‘,<br>    regexpTag = ‘[object RegExp]‘,<br>    setTag = ‘[object Set]‘,<br>    stringTag = ‘[object String]‘,<br>    weakMapTag = ‘[object WeakMap]‘;</p>
<p>var arrayBufferTag = ‘[object ArrayBuffer]‘,<br>    float32Tag = ‘[object Float32Array]‘,<br>    float64Tag = ‘[object Float64Array]‘,<br>    int8Tag = ‘[object Int8Array]‘,<br>    int16Tag = ‘[object Int16Array]‘,<br>    int32Tag = ‘[object Int32Array]‘,<br>    uint8Tag = ‘[object Uint8Array]‘,<br>    uint8ClampedTag = ‘[object Uint8ClampedArray]‘,<br>    uint16Tag = ‘[object Uint16Array]‘,<br>    uint32Tag = ‘[object Uint32Array]‘;</p>
<h2 id="借助-JSON-全局对象"><a href="#借助-JSON-全局对象" class="headerlink" title="借助 JSON 全局对象"></a>借助 JSON 全局对象</h2><p>相比于上面介绍的三个库的做法，针对纯 JSON 数据对象的深复制，使用 JSON 全局对象的 <code>parse</code> 和 <code>stringify</code> 方法来实现深复制也算是一个简单讨巧的方法。然而使用这种方法会有一些隐藏的坑，它能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。</p>
<p>function jsonClone(obj) {<br>    return JSON.parse(JSON.stringify(obj));<br>}<br>var clone = jsonClone({ a:1 });</p>
<h2 id="拥抱未来的深复制方法"><a href="#拥抱未来的深复制方法" class="headerlink" title="拥抱未来的深复制方法"></a>拥抱未来的深复制方法</h2><p>这个实现方法具体可以看一个小玩意儿——<a href="https://github.com/cherryjs/cherry.js" target="_blank" rel="noopener">Cherry.js</a>，使用方法大概是这样的：</p>
<p>function X() {<br>    this.x = 5;<br>    this.arr = [1,2,3];<br>}<br>var obj = { d: new Date(), r: /abc/ig, x: new X(), arr: [1,2,3] },<br>    obj2,<br>    clone;</p>
<p>obj.x.xx = new X();<br>obj.arr.testProp = “test”;<br>clone = obj.$clone();</p>
<p>首先定义一个辅助函数，用于在预定义对象的 Prototype 上定义方法：</p>
<p>function defineMethods(protoArray, nameToFunc) {<br>    protoArray.forEach(function(proto) {<br>        var names = Object.keys(nameToFunc),<br>            i = 0;</p>
<pre><code>    for (; i &lt; names.length; i++) {
        Object.defineProperty(proto, names\[i\], {
            enumerable: false,
            configurable: true,
            writable: true,
            value: nameToFunc\[names\[i\]\]
        });
    }
});
</code></pre><p>}</p>
<p>为了避免和源生方法冲突，在方法名前加了一个 <code>$</code> 符号。而这个方法的具体实现很简单，就是递归深复制。其中需要解释一下两个参数：<code>srcStack</code>和<code>dstStack</code>。它们的主要用途是对存在环的对象进行深复制。比如源对象中的子对象<code>srcStack[7]</code>在深复制以后，对应于<code>dstStack[7]</code>。该实现方法参考了 lodash 的实现。关于递归最重要的就是 Object 和 Array 对象：</p>
<p>/*=====================================*<br> * Object.prototype<br> * - $clone()<br><em>=====================================</em>/</p>
<p>defineMethods([ Object.prototype ], {<br>    ‘$clone’: function (srcStack, dstStack) {<br>        var obj = Object.create(Object.getPrototypeOf(this)),<br>            keys = Object.keys(this),<br>            index,<br>            prop;</p>
<pre><code>    srcStack = srcStack || \[\];
    dstStack = dstStack || \[\];
    srcStack.push(this);
    dstStack.push(obj);

    for (var i = 0; i &lt; keys.length; i++) {
        prop = this\[keys\[i\]\];
        if (prop === null || prop === undefined) {
            obj\[keys\[i\]\] = prop;
        }
        else if (!prop.$isFunction()) {
            if (prop.$isPlainObject()) {
                index = srcStack.lastIndexOf(prop);
                if (index &gt; 0) {
                    obj\[keys\[i\]\] = dstStack\[index\];
                    continue;
                }
            }
            obj\[keys\[i\]\] = prop.$clone(srcStack, dstStack);
        }
    }
    return obj;
}
</code></pre><p>});</p>
<p>/*=====================================*<br> * Array.prototype<br> * - $clone()<br><em>=====================================</em>/</p>
<p>defineMethods([ Array.prototype ], {<br>    ‘$clone’: function (srcStack, dstStack) {<br>        var thisArr = this.valueOf(),<br>            newArr = [],<br>            keys = Object.keys(thisArr),<br>            index,<br>            element;</p>
<pre><code>    srcStack = srcStack || \[\];
    dstStack = dstStack || \[\];
    srcStack.push(this);
    dstStack.push(newArr);

    for (var i = 0; i &lt; keys.length; i++) {
        element = thisArr\[keys\[i\]\];
        if (element === undefined || element === null) {
            newArr\[keys\[i\]\] = element;
        } else if (!element.$isFunction()) {
            if (element.$isPlainObject()) {
                index = srcStack.lastIndexOf(element);
                if (index &gt; 0) {
                    newArr\[keys\[i\]\] = dstStack\[index\];
                    continue;
                }
            }
        }
        newArr\[keys\[i\]\] = element.$clone(srcStack, dstStack);
    }
    return newArr;
}
</code></pre><p>});</p>
<p>接下来要针对 Date 和 RegExp 对象的深复制进行一些特殊处理：</p>
<p>/*=====================================*<br> * Date.prototype<br> * - $clone<br> <em>=====================================</em>/</p>
<p>defineMethods([ Date.prototype ], {<br>    ‘$clone’: function() { return new Date(this.valueOf()); }<br>});</p>
<p>/*=====================================*<br> * RegExp.prototype<br> * - $clone<br> <em>=====================================</em>/</p>
<p>defineMethods([ RegExp.prototype ], {<br>    ‘$clone’: function () {<br>        var pattern = this.valueOf();<br>        var flags = ‘’;<br>        flags += pattern.global ? ‘g’ : ‘’;<br>        flags += pattern.ignoreCase ? ‘i’ : ‘’;<br>        flags += pattern.multiline ? ‘m’ : ‘’;<br>        return new RegExp(pattern.source, flags);<br>    }<br>});</p>
<p>接下来就是 Number, Boolean 和 String 的 <code>$clone</code> 方法，虽然很简单，但这也是必不可少的。这样就能防止像单个字符串这样的对象错误地去调用 <code>Object.prototype.$clone</code>。</p>
<p>/*=====================================*<br> * Number / Boolean / String.prototype<br> * - $clone()<br> <em>=====================================</em>/</p>
<p>defineMethods([<br>    Number.prototype,<br>    Boolean.prototype,<br>    String.prototype<br>], {<br>    ‘$clone’: function() { return this.valueOf(); }<br>});</p>
<h2 id="比较各个深复制方法"><a href="#比较各个深复制方法" class="headerlink" title="比较各个深复制方法"></a>比较各个深复制方法</h2><p>特性</p>
<p>jQuery</p>
<p>lodash</p>
<p>JSON.parse</p>
<p>所谓“拥抱未来的深复制实现”</p>
<p>浏览器兼容性</p>
<p>IE6+ (1.x) &amp; IE9+ (2.x)</p>
<p>IE6+ (Compatibility) &amp; IE9+ (Modern)</p>
<p>IE8+</p>
<p>IE9+</p>
<p>能够深复制存在环的对象</p>
<p>抛出异常 RangeError: Maximum call stack size exceeded</p>
<p>支持</p>
<p>抛出异常 TypeError: Converting circular structure to JSON</p>
<p>支持</p>
<p>对 Date, RegExp 的深复制支持</p>
<p>×</p>
<p>支持</p>
<p>×</p>
<p>支持</p>
<p>对 ES6 新引入的标准对象的深复制支持</p>
<p>×</p>
<p>支持</p>
<p>×</p>
<p>×</p>
<p>复制数组的属性</p>
<p>×</p>
<p><a href="https://github.com/lodash/lodash/blob/5166064453ed6164b76fb20f8dd340d23dd334e5/lodash._baseclone/index.js#215" target="_blank" rel="noopener">仅支持RegExp#exec返回的数组结果</a></p>
<p>×</p>
<p>支持</p>
<p>是否保留非源生对象的类型</p>
<p>×</p>
<p>×</p>
<p>×</p>
<p>支持</p>
<p>复制不可枚举元素</p>
<p>×</p>
<p>×</p>
<p>×</p>
<p>×</p>
<p>复制函数</p>
<p>×</p>
<p>×</p>
<p>×</p>
<p>×</p>
<h2 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h2><p>为了测试各种深复制方法的执行效率，使用了如下的测试用例</p>
<p>ar x = {};<br>for (var i = 0; i &lt; 1000; i++) {<br>    x[i] = {};<br>    for (var j = 0; j &lt; 1000; j++) {<br>        x[i][j] = Math.random();<br>    }<br>}</p>
<p>var start = Date.now();<br>var y = clone(x);<br>console.log(Date.now() - start);</p>
<p>下面来看看各个实现方法的具体效率如何，所使用的浏览器是 Mac 上的 Chrome 43.0.2357.81 (64-bit) 版本，可以看出来在3次的实验中，所实现的方法比 lodash 稍逊一筹，但比jQuery的效率也会高一些。   原文地址:<a href="http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/" target="_blank" rel="noopener">http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2017/02/16/vue-e5-ae-9e-e4-be-8b-e8-af-a6-e8-a7-a3-e4-b8-8e-e7-94-9f-e5-91-bd-e5-91-a8-e6-9c-9f/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe"/>
      <meta itemprop="description" content=""/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/16/vue-e5-ae-9e-e4-be-8b-e8-af-a6-e8-a7-a3-e4-b8-8e-e7-94-9f-e5-91-bd-e5-91-a8-e6-9c-9f/" class="post-title-link" itemprop="url">Vue实例详解与生命周期</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-16 10:17:19" itemprop="dateCreated datePublished" datetime="2017-02-16T10:17:19+08:00">2017-02-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习记录/" itemprop="url" rel="index"><span itemprop="name">学习记录</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Vue实例初始化的选项配置对象详解"><a href="#1-Vue实例初始化的选项配置对象详解" class="headerlink" title="1.Vue实例初始化的选项配置对象详解"></a>1.Vue实例初始化的选项配置对象详解</h2><h3 id="1-1Vue实例的的data对象"><a href="#1-1Vue实例的的data对象" class="headerlink" title="1.1Vue实例的的data对象"></a>1.1Vue实例的的data对象</h3><p>Vue的实例的数据对象data 我们已经用了很多了，数据绑定离不开data里面的数据。也是Vue的核心属性。 它是Vue绑定数据到HTML标签的数据源泉，另外Vue框架会自动监视data里面的数据变化，自动更新数据到HTML标签上去。本质原理是：Vue会自动将data里面的数据进行递归抓换成getter和setter，然后就可以自动更新HTML标签了，当然用getter和setter所以老的浏览器Vue支持的不够好。</p>
<ul>
<li><p>data对象的类型：</p>
<ul>
<li>类型是Object或者Function。</li>
<li>如果是组件对象中，data必须是Function类型。【后面学了组件后就明白了，暂时对组件先放放。】</li>
</ul>
</li>
<li><p>实例：</p>
</li>
</ul>
<p>// 创建普通的Vue实例<br>var vm = new Vue({<br>  data: data<br>})</p>
<p>// 组件定义【后面会详细讲的】<br>// Vue.extend() 中 data 必须是函数<br>var Component = Vue.extend({<br>  data: function () {   //这里必须是函数！！！！<br>    return { a: 1 }<br>  }<br>})</p>
<h3 id="1-2-Vue实例的computed"><a href="#1-2-Vue实例的computed" class="headerlink" title="1.2. Vue实例的computed"></a>1.2. Vue实例的computed</h3><p>Vue的计算属性（computed)的属性会自动混入Vue的实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。这就很强大了，再计算属性中定义的函数里面可以直接使用指向了vue实例的this，异常方便。</p>
<p>类型:{ 键：函数}{ [key: string]: Function | { get: Function, set: Function } } 当然，可以省略setter,如果省略了setter，那么值就可以是普通函数，但是必须有返回值。 官方的实例:</p>
<p>var vm = new Vue({<br>data: { a: 1 },<br>computed: {<br>  // 仅读取，值只须为函数<br>  aDouble: function () {<br>    return this.a * 2<br>  },<br>  // 读取和设置<br>  aPlus: {<br>    get: function () {<br>      return this.a + 1<br>    },<br>    set: function (v) {<br>      this.a = v - 1<br>    }<br>  }<br>}<br>})<br>vm.aPlus   // -&gt; 2<br>vm.aPlus = 3<br>vm.a       // -&gt; 2<br>vm.aDouble // -&gt; 4</p>
<h3 id="1-3-methods"><a href="#1-3-methods" class="headerlink" title="1.3. methods"></a>1.3. methods</h3><ul>
<li>类型: { [key: string]: Function }</li>
<li>详细:</li>
</ul>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 示例:</p>
<p>var vm = new Vue({<br>  data: { a: 1 },<br>  methods: {<br>    plus: function () {<br>      this.a++<br>    }<br>  }<br>})<br>vm.plus()<br>vm.a // 2</p>
<h3 id="1-4-watch"><a href="#1-4-watch" class="headerlink" title="1.4. watch"></a>1.4. watch</h3><p>类型:<code>{ [key: string]: string | Function | Object }</code> 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 示例:</p>
<p>var vm = new Vue({<br>  data: {<br>    a: 1,<br>    b: 2,<br>    c: 3<br>  },<br>  watch: {<br>    // 监控a变量变化的时候，自动执行此函数<br>    a: function (val, oldVal) {<br>      console.log(‘new: %s, old: %s’, val, oldVal)<br>    },<br>    // 深度 watcher<br>    c: {<br>      handler: function (val, oldVal) { /<em> … </em>/ },<br>      deep: true<br>    }<br>  }<br>})<br>vm.a = 2 // -&gt; new: 2, old: 1<br>//注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</p>
<p>参考综合案例：</p>
<p>&lt;!DOCTYPE html&gt; </p>
<html lang="en"><br><head><meta name="generator" content="Hexo 3.8.0"><br>  <meta charset="UTF-8"><br>  <title>Vue入门之数据监控</title><br>  <script src="https://unpkg.com/vue/dist/vue.js"></script><br></head><br><body><br>  <div id="app"><br>    <p>{ { number }}</p><br>    <input type="button" name="btnGetNumber" value="增加" v-on:click="getNumber()"><br>  </div><br>  <script><br>    var app = new Vue({<br>      el: ‘#app’,<br>      data: {<br>        number: 1<br>      },<br>      methods: {<br>        // 事件响应方法的逻辑代码<br>        getNumber: function (e) {<br>          this.number += 1;   // 不管是内联方法调用，还是绑定事件处理器两种方式执行事件响应方法的时候 this都是指向 app<br>        }<br>      },<br>      watch: {<br>        // 监控number的变化，并自动执行下面的函数<br>        number: function (val, oldVal) {<br>          console.log(‘val:’ + val + ‘ - oldVal: ‘ + oldVal);<br>        }<br>      }<br>    });<br>  </script><br></body><br></html>

<h3 id="1-5-设置el的详解"><a href="#1-5-设置el的详解" class="headerlink" title="1.5. 设置el的详解"></a>1.5. 设置el的详解</h3><p>类型:<code>string | HTMLElement</code> 限制： 只在由 new 创建的实例中遵守。 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标,也就是说Vue绑定数据到哪里去找。可以是<code>CSS 选择器</code>，也可以是一个 <code>HTMLElement实例</code>。 在实例挂载之后(生命周期的内容后面会详细讲的奥)， 元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译</p>
<p>// 几乎所有例子都用到这个，<br>var app = new Vue({<br>  el: ‘#app’,<br>  …<br>});</p>
<h2 id="2-Vue实例的生命周期"><a href="#2-Vue实例的生命周期" class="headerlink" title="2. Vue实例的生命周期"></a>2. Vue实例的生命周期</h2><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们注册js方法，可以让我们达到控制整个过程的目的地.。 首先看看下面的一张生命周期的图：<img src="http://zhongmin.me/wp-content/uploads/2017/02/o_lifecycle-标注版本.png" alt> Vue提供的可以注册的钩子都在上图片的红色框标注。 他们是：</p>
<ul>
<li><code>beforeCreate</code></li>
</ul>
<p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>
<ul>
<li><code>created</code></li>
</ul>
<p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<ul>
<li><code>beforeMount</code></li>
</ul>
<p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<ul>
<li><code>mounted</code></li>
</ul>
<p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p>
<ul>
<li><code>beforeUpdate</code></li>
</ul>
<p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<ul>
<li><code>updated</code></li>
</ul>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。</p>
<ul>
<li><code>beforeDestroy</code></li>
</ul>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<ul>
<li><code>destroyed</code></li>
</ul>
<p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 示例:</p>
<p>&lt;!DOCTYPE html&gt; </p>
<html lang="en"><br><head><meta name="generator" content="Hexo 3.8.0"><br>  <meta charset="UTF-8"><br>  <title>Vue入门之生命周期</title><br>  <script src="https://unpkg.com/vue/dist/vue.js"></script><br></head><br><body><br>  <div id="app"><br>    <p>{ { number }}</p><br>    <input type="text" name="btnSetNumber" v-model="number"><br>  </div><br>  <script><br>    var app = new Vue({<br>      el: ‘#app’,<br>      data: {<br>        number: 1<br>      },<br>      beforeCreate: function () {<br>        console.log(‘beforeCreate 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      cteated: function () {<br>        console.log(‘cteated 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      beforeMount: function () {<br>        console.log(‘beforeMount 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      mounted: function () {<br>        console.log(‘mounted 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      beforeUpdate: function () {<br>        console.log(‘beforeUpdate 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      updated: function () {<br>        console.log(‘updated 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      beforeDestroy: function () {<br>        console.log(‘beforeDestroy 钩子执行…’);<br>        console.log(this.number)<br>      },<br>      destroyed: function () {<br>        console.log(‘destroyed 钩子执行…’);<br>        console.log(this.number)<br>      },<br>    });<br>  </script><br></body><br></html>

<p>综合案列:</p>
<p>import Axios from ‘axios’       // 这是一个轻量级的ajax库，import是es6模块导入的语法。<br>export default {                // 这是一个vue的模块，后面讲奥。<br>  name: ‘app’,<br>  components: {<br>  },<br>  data: function () {<br>    return {<br>      list: []<br>    }<br>  },<br>  mounted: function () {          // 挂在完成后的生命周期钩子注册。<br>    this.$nextTick(function () {  // 等待下一次更新完成后执行业务处理代码。<br>      Axios.get(‘/api/menulist’, {// 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新<br>        params: {<br>        }<br>      }).then(function (res) {<br>        this.list = res.data<br>      }.bind(this))<br>    })<br>  }<br>}</p>
<h2 id="3-Vue实例的全局配置"><a href="#3-Vue实例的全局配置" class="headerlink" title="3. Vue实例的全局配置"></a>3. Vue实例的全局配置</h2><p>这一块都是一些小的知识点，我就不赘述了，直接copy <a href="https://cn.vuejs.org/v2/api/#silent" target="_blank" rel="noopener">官网</a> Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p>
<ul>
<li><p>silent</p>
<ul>
<li>类型： boolean</li>
<li>默认值： false</li>
<li><p>用法：</p>
<p>Vue.config.silent = true<br>//取消 Vue 所有的日志与警告。</p>
</li>
</ul>
</li>
<li><p>optionMergeStrategies</p>
<ul>
<li>类型： { [key: string]: Function }</li>
<li>默认值： {}</li>
<li>用法：</li>
</ul>
</li>
<li><p>devtools</p>
<ul>
<li>类型： boolean</li>
<li>默认值： true (生产版为 false)</li>
<li><p>用法：</p>
<pre><code>// 务必在加载 Vue 之后，立即同步设置以下内容
Vue.config.devtools = true
//配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>errorHandler</p>
<ul>
<li>类型： Function</li>
<li>默认值： 默认抛出错误</li>
<li><p>用法：</p>
<pre><code>Vue.config.errorHandler = function (err, vm) {
// handle error
}
//指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。
//Sentry, an error tracking service, provides official integration using this option.
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>ignoredElements</p>
<ul>
<li>类型: Array</li>
<li>默认值: []</li>
<li><p>用法:</p>
<pre><code>Vue.config.ignoredElements = [
&apos;my-custom-web-component&apos;, &apos;another-web-component&apos;
]
须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>keyCodes</p>
<ul>
<li>类型： { [key: string]: number | Array }</li>
<li>默认值： {}</li>
<li><p>用法：</p>
<p>Vue.config.keyCodes = {<br>v: 86,<br>f1: 112,<br>mediaPlayPause: 179,<br>up: [38, 87]<br>}api<br>//给 v-on 自定义键位别名。</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xiaohe</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">153</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohe</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
