<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="从零开始">
<meta property="og:url" content="http://b.zhongmin.me/page/3/index.html">
<meta property="og:site_name" content="从零开始">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从零开始">





  
  
  <link rel="canonical" href="http://b.zhongmin.me/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>从零开始</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/04/21/abstractqueuedsynchronizer-e5-9b-9b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/21/abstractqueuedsynchronizer-e5-9b-9b/" class="post-title-link" itemprop="url">AbstractQueuedSynchronizer(四)-CyclicBarrier</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-21 18:04:44" itemprop="dateCreated datePublished" datetime="2018-04-21T18:04:44+08:00">2018-04-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 实例代码如下</p>
<p>public class CyclicBarrierTest {</p>
<pre><code>static CyclicBarrier c = new CyclicBarrier(2);

public static void main(String\[\] args) {
    new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                c.await();
            } catch (Exception e) {

            }
            System.out.println(1);
        }
    }).start();

    try {
        c.await();
    } catch (Exception e) {

    }
    System.out.println(2);
}
</code></pre><p>}</p>
<p>输出</p>
<p>2<br>1</p>
<p>如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)则主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。 CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。代码如下：</p>
<p>public class CyclicBarrierTest2 {</p>
<pre><code>static CyclicBarrier c = new CyclicBarrier(2, new A());

public static void main(String\[\] args) {
    new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                c.await();
            } catch (Exception e) {

            }
            System.out.println(1);
        }
    }).start();

    try {
        c.await();
    } catch (Exception e) {

    }
    System.out.println(2);
}

static class A implements Runnable {

    @Override
    public void run() {
        System.out.println(3);
    }

}
</code></pre><p>}</p>
<p>输出</p>
<p>3<br>1<br>2</p>
<h3 id="CyclicBarrier的应用场景"><a href="#CyclicBarrier的应用场景" class="headerlink" title="CyclicBarrier的应用场景"></a>CyclicBarrier的应用场景</h3><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。</p>
<h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><p>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。 CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。</p>
<h3 id="CyclicBarrier源码"><a href="#CyclicBarrier源码" class="headerlink" title="CyclicBarrier源码"></a>CyclicBarrier源码</h3><p><img src="https://zhongmin.me/wp-content/uploads/2018/04/1JHHK29RYRN5SC07YS0C1-960x418.png" alt> 首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。 因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。 废话结束，先上基本属性和构造方法，往下拉一点点，和图一起看：</p>
<p>public class CyclicBarrier {<br>    // 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做”一代”<br>    private static class Generation {<br>        boolean broken = false;<br>    }</p>
<pre><code>/\*\* The lock for guarding barrier entry */
private final ReentrantLock lock = new ReentrantLock();
// CyclicBarrier 是基于 Condition 的
// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上
private final Condition trip = lock.newCondition();

// 参与的线程数
private final int parties;

// 如果设置了这个，代表越过栅栏之前，要执行相应的操作
private final Runnable barrierCommand;

// 当前所处的“代”
private Generation generation = new Generation();

// 还没有到栅栏的线程数，这个值初始为 parties，然后递减
// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量
private int count;

public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
</code></pre><p>用一图来描绘下 CyclicBarrier 里面的一些概念<img src="https://zhongmin.me/wp-content/uploads/2018/04/MW9NXA12SYPEOE13FC-833x640.png" alt> 看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。 首先，先看怎么开启新的一代：</p>
<p>// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”<br>private void nextGeneration() {<br>    // 首先，需要唤醒所有的在栅栏上等待的线程<br>    trip.signalAll();<br>    // 更新 count 的值<br>    count = parties;<br>    // 重新生成“新一代”<br>    generation = new Generation();<br>}</p>
<p>看看怎么打破一个栅栏：</p>
<p>private void breakBarrier() {<br>    // 设置状态 broken 为 true<br>    generation.broken = true;<br>    // 重置 count 为初始值 parties<br>    count = parties;<br>    // 唤醒所有已经在等待的线程<br>    trip.signalAll();<br>}</p>
<p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p>
<p>// 不带超时机制<br>public int await() throws InterruptedException, BrokenBarrierException {<br>    try {<br>        return dowait(false, 0L);<br>    } catch (TimeoutException toe) {<br>        throw new Error(toe); // cannot happen<br>    }<br>}<br>// 带超时机制，如果超时抛出 TimeoutException 异常<br>public int await(long timeout, TimeUnit unit)<br>    throws InterruptedException,<br>           BrokenBarrierException,<br>           TimeoutException {<br>    return dowait(true, unit.toNanos(timeout));<br>}</p>
<p>继续往里看：</p>
<p>private int dowait(boolean timed, long nanos)<br>        throws InterruptedException, BrokenBarrierException,<br>               TimeoutException {<br>    final ReentrantLock lock = this.lock;<br>    // 先要获取到锁，然后在 finally 中要记得释放锁<br>    // 如果记得 Condition 部分的话，我们知道 condition 的 await 会释放锁，signal 的时候需要重新获取锁<br>    lock.lock();<br>    try {<br>        final Generation g = generation;<br>        // 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常<br>        if (g.broken)<br>            throw new BrokenBarrierException();<br>        // 检查中断状态，如果中断了，抛出 InterruptedException 异常<br>        if (Thread.interrupted()) {<br>            breakBarrier();<br>            throw new InterruptedException();<br>        }<br>        // index 是这个 await 方法的返回值<br>        // 注意到这里，这个是从 count 递减后得到的值<br>        int index = –count;</p>
<pre><code>    // 如果等于 0，说明所有的线程都到栅栏上了，准备通过
    if (index == 0) {  // tripped
        boolean ranAction = false;
        try {
            // 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行
            final Runnable command = barrierCommand;
            if (command != null)
                command.run();
            // 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况
            ranAction = true;
            // 唤醒等待的线程，然后开启新的一代
            nextGeneration();
            return 0;
        } finally {
            if (!ranAction)
                // 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏
                // 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties
                breakBarrier();
        }
    }

    // loop until tripped, broken, interrupted, or timed out
    // 如果是最后一个线程调用 await，那么上面就返回了
    // 下面的操作是给那些不是最后一个到达栅栏的线程执行的
    for (;;) {
        try {
            // 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await
            if (!timed)
                trip.await();
            else if (nanos &gt; 0L)
                nanos = trip.awaitNanos(nanos);
        } catch (InterruptedException ie) {
            // 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断
            if (g == generation &amp;&amp; ! g.broken) {
                // 打破栅栏
                breakBarrier();
                // 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法
                throw ie;
            } else {
                // 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，
                // 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可
                // 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，
                // 而是之后抛出 BrokenBarrierException 异常
                Thread.currentThread().interrupt();
            }
        }

          // 唤醒后，检查栅栏是否是“破的”
        if (g.broken)
            throw new BrokenBarrierException();

        // 这个 for 循环除了异常，就是要从这里退出了
        // 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代
        // 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的
        // 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，
        // 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回
        // 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码
        if (g != generation)
            return index;

        // 如果醒来发现超时了，打破栅栏，抛出异常
        if (timed &amp;&amp; nanos &lt;= 0L) {
            breakBarrier();
            throw new TimeoutException();
        }
    }
} finally {
    lock.unlock();
}
</code></pre><p>}</p>
<p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？ 下面开始收尾工作。 首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>
<p>public int getNumberWaiting() {<br>    final ReentrantLock lock = this.lock;<br>    lock.lock();<br>    try {<br>        return parties - count;<br>    } finally {<br>        lock.unlock();<br>    }<br>}</p>
<p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>
<p>public boolean isBroken() {<br>    final ReentrantLock lock = this.lock;<br>    lock.lock();<br>    try {<br>        return generation.broken;<br>    } finally {<br>        lock.unlock();<br>    }<br>}</p>
<p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>
<ol>
<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>
<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>
<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>
</ol>
<p>最后，我们来看看怎么重置一个栅栏：</p>
<p>public void reset() {<br>    final ReentrantLock lock = this.lock;<br>    lock.lock();<br>    try {<br>        breakBarrier();   // break the current generation<br>        nextGeneration(); // start a new generation<br>    } finally {<br>        lock.unlock();<br>    }<br>}</p>
<p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？ 首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/04/21/abstractqueuedsynchronizer-e4-b8-89-countdownlatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/21/abstractqueuedsynchronizer-e4-b8-89-countdownlatch/" class="post-title-link" itemprop="url">AbstractQueuedSynchronizer(三)-CountDownLatch</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-21 16:52:54" itemprop="dateCreated datePublished" datetime="2018-04-21T16:52:54+08:00">2018-04-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏;</strong></p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我们经常会写这个代码。 假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。 调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p>
<p>class Driver2 { // …<br>    void main() throws InterruptedException {<br>        CountDownLatch doneSignal = new CountDownLatch(N);<br>        Executor e = Executors.newFixedThreadPool(8);</p>
<pre><code>    // 创建 N 个任务，提交给线程池来执行
    for (int i = 0; i &lt; N; ++i) // create and start threads
        e.execute(new WorkerRunnable(doneSignal, i));

    // 等待所有的任务完成，这个方法才会返回
    doneSignal.await();           // wait for all to finish
}
</code></pre><p>}</p>
<p>class WorkerRunnable implements Runnable {<br>    private final CountDownLatch doneSignal;<br>    private final int i;</p>
<pre><code>WorkerRunnable(CountDownLatch doneSignal, int i) {
    this.doneSignal = doneSignal;
    this.i = i;
}

public void run() {
    try {
        doWork(i);
        // 这个线程的任务完成了，调用 countDown 方法
        doneSignal.countDown();
    } catch (InterruptedException ex) {
    } // return;
}

void doWork() { ...}
</code></pre><p>}</p>
<p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。 我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p>
<p>class Driver { // …<br>    void main() throws InterruptedException {<br>        CountDownLatch startSignal = new CountDownLatch(1);<br>        CountDownLatch doneSignal = new CountDownLatch(N);</p>
<pre><code>    for (int i = 0; i &lt; N; ++i) // create and start threads
        new Thread(new Worker(startSignal, doneSignal)).start();

    // 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。
    doSomethingElse();            // don&apos;t let run yet
    // 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过
    startSignal.countDown();      // let all threads proceed
    doSomethingElse();
    // 等待所有任务结束
    doneSignal.await();           // wait for all to finish
}
</code></pre><p>}</p>
<p>class Worker implements Runnable {<br>    private final CountDownLatch startSignal;<br>    private final CountDownLatch doneSignal;</p>
<pre><code>Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
    this.startSignal = startSignal;
    this.doneSignal = doneSignal;
}

public void run() {
    try {
        // 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里
        // 等大家都准备好了，再打开这个门栓
        startSignal.await();
        doWork();
        doneSignal.countDown();
    } catch (InterruptedException ex) {
    } // return;
}

void doWork() { ...}
</code></pre><p>}</p>
<p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏。<img src="https://zhongmin.me/wp-content/uploads/2018/04/Q9NL0GHWG4SZH@TGXVU-960x462.png" alt> 如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>构造方法，需要传入一个不小于 0 的整数：</p>
<p>public CountDownLatch(int count) {<br>    if (count &lt; 0) throw new IllegalArgumentException(“count &lt; 0”);<br>    this.sync = new Sync(count);<br>}<br>// 老套路了，内部封装一个 Sync 类继承自 AQS<br>private static final class Sync extends AbstractQueuedSynchronizer {<br>    Sync(int count) {<br>        // 这样就 state == count 了<br>        setState(count);<br>    }<br>    …<br>}</p>
<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个线程会负责唤醒调用了 await 方法的所有线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。 对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。 我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>
<p>public class CountDownLatchDemo {</p>
<pre><code>public static void main(String\[\] args) {

    CountDownLatch latch = new CountDownLatch(2);

    Thread t1 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException ignore) {
            }
            // 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()
            latch.countDown();
        }
    }, &quot;t1&quot;);

    Thread t2 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException ignore) {
            }
            // 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()
            latch.countDown();
        }
    }, &quot;t2&quot;);

    t1.start();
    t2.start();

    Thread t3 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                // 阻塞，等待 state 减为 0
                latch.await();
                System.out.println(&quot;线程 t3 从 await 中返回了&quot;);
            } catch (InterruptedException e) {
                System.out.println(&quot;线程 t3 await 被中断&quot;);
                Thread.currentThread().interrupt();
            }
        }
    }, &quot;t3&quot;);
    Thread t4 = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                // 阻塞，等待 state 减为 0
                latch.await();
                System.out.println(&quot;线程 t4 从 await 中返回了&quot;);
            } catch (InterruptedException e) {
                System.out.println(&quot;线程 t4 await 被中断&quot;);
                Thread.currentThread().interrupt();
            }
        }
    }, &quot;t4&quot;);

    t3.start();
    t4.start();
}
</code></pre><p>}</p>
<p>上述程序，大概在过了 10 秒左右的时候，会输出：</p>
<p>线程 t3 从 await 中返回了<br>线程 t4 从 await 中返回了<br>// 这两条输出，顺序不是绝对的<br>// 后面的分析，我们假设 t3 先进入阻塞队列</p>
<p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。 首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p>
<p>public void await() throws InterruptedException {<br>    sync.acquireSharedInterruptibly(1);<br>}<br>public final void acquireSharedInterruptibly(int arg)<br>        throws InterruptedException {<br>    // 是否被打断<br>    if (Thread.interrupted())<br>        throw new InterruptedException();<br>    // t3 和 t4 调用 await 的时候，state 都大于 0。<br>    // 也就是说，这个 if 返回 true，然后往里看<br>    if (tryAcquireShared(arg) &lt; 0)<br>        doAcquireSharedInterruptibly(arg);<br>}<br>// 只有当 state == 0 的时候，这个方法才会返回 1<br>protected int tryAcquireShared(int acquires) {<br>    return (getState() == 0) ? 1 : -1;<br>}</p>
<p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p>
<p>private void doAcquireSharedInterruptibly(int arg)<br>    throws InterruptedException {<br>    // 1. 入队<br>    final Node node = addWaiter(Node.SHARED);<br>    boolean failed = true;<br>    try {<br>        for (;;) {<br>            final Node p = node.predecessor();<br>            if (p == head) {<br>                // 同上，只要 state 不等于 0，那么这个方法返回 -1<br>                int r = tryAcquireShared(arg);<br>                if (r &gt;= 0) {<br>                    setHeadAndPropagate(node, r);<br>                    p.next = null; // help GC<br>                    failed = false;<br>                    return;<br>                }<br>            }<br>            // 2<br>            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                throw new InterruptedException();<br>        }<br>    } finally {<br>        if (failed)<br>            cancelAcquire(node);<br>    }<br>}</p>
<p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：<img src="https://zhongmin.me/wp-content/uploads/2018/04/F5T7HH6Q74Q54SNK-960x348.png" alt> 由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：<img src="https://zhongmin.me/wp-content/uploads/2018/04/65JC_5LB3VTXT_QTPV5-960x353.png" alt> 然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。 我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：<img src="https://zhongmin.me/wp-content/uploads/2018/04/0GP9UXKSZMG9WQ1OTUYC-960x353.png" alt> 然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。 接下来，我们来看唤醒的流程，我们假设用 10 初始化 CountDownLatch。<img src="https://zhongmin.me/wp-content/uploads/2018/04/62L7AD4M7O0SNY2C-680x640.png" alt> 当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。 我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p>
<p>public void countDown() {<br>    sync.releaseShared(1);<br>}<br>public final boolean releaseShared(int arg) {<br>    // 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true<br>    // 否则只是简单的 state = state - 1 那么 countDown 方法就结束了<br>    if (tryReleaseShared(arg)) {<br>        // 唤醒 await 的线程<br>        doReleaseShared();<br>        return true;<br>    }<br>    return false;<br>}<br>// 这个方法很简单，用自旋的方法实现 state 减 1<br>protected boolean tryReleaseShared(int releases) {<br>    for (;;) {<br>        int c = getState();<br>        if (c == 0)<br>            return false;<br>        int nextc = c-1;<br>        if (compareAndSetState(c, nextc))<br>            return nextc == 0;<br>    }<br>}</p>
<p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p>
<p>/ 调用这个方法的时候，state == 0<br>// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，其他的之后还会仔细分析<br>private void doReleaseShared() {<br>    for (;;) {<br>        Node h = head;<br>        if (h != null &amp;&amp; h != tail) {<br>            int ws = h.waitStatus;<br>            // t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了<br>            if (ws == Node.SIGNAL) {<br>                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br>                    continue;            // loop to recheck cases<br>                // 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点<br>                // 在这里，也就是唤醒 t3<br>                unparkSuccessor(h);<br>            }<br>            else if (ws == 0 &amp;&amp;<br>                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // todo<br>                continue;                // loop on failed CAS<br>        }<br>        if (h == head)                   // loop if head changed<br>            break;<br>    }<br>}</p>
<p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p>
<p>private void doAcquireSharedInterruptibly(int arg)<br>    throws InterruptedException {<br>    final Node node = addWaiter(Node.SHARED);<br>    boolean failed = true;<br>    try {<br>        for (;;) {<br>            final Node p = node.predecessor();<br>            if (p == head) {<br>                int r = tryAcquireShared(arg);<br>                if (r &gt;= 0) {<br>                    setHeadAndPropagate(node, r); // 2. 这里是下一步<br>                    p.next = null; // help GC<br>                    failed = false;<br>                    return;<br>                }<br>            }<br>            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                // 1. 唤醒后这个方法返回<br>                parkAndCheckInterrupt())<br>                throw new InterruptedException();<br>        }<br>    } finally {<br>        if (failed)<br>            cancelAcquire(node);<br>    }<br>}</p>
<p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p>
<p>private void setHeadAndPropagate(Node node, int propagate) {<br>    Node h = head; // Record old head for check below<br>    setHead(node);</p>
<pre><code>// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4
// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了
if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
    (h = head) == null || h.waitStatus &lt; 0) {
    Node s = node.next;
    if (s == null || s.isShared())
        // 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了
        doReleaseShared();
}
</code></pre><p>}</p>
<p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p>
<p>// 调用这个方法的时候，state == 0<br>private void doReleaseShared() {<br>    for (;;) {<br>        Node h = head;<br>        // 1. h == null: 说明阻塞队列为空<br>        // 2. h == tail: 说明头结点可能是刚刚初始化的头节点，<br>        //   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了<br>        // 所以这两种情况不需要进行唤醒后继节点<br>        if (h != null &amp;&amp; h != tail) {<br>            int ws = h.waitStatus;<br>            // t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了<br>            if (ws == Node.SIGNAL) {<br>                // 这里 CAS 失败的场景请看下面的解读<br>                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))<br>                    continue;            // loop to recheck cases<br>                // 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点<br>                // 在这里，也就是唤醒 t4<br>                unparkSuccessor(h);<br>            }<br>            else if (ws == 0 &amp;&amp;<br>                     // 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1<br>                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))<br>                continue;                // loop on failed CAS<br>        }<br>        // 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环<br>        // 否则，就是 head 没变，那么退出循环，<br>        // 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的<br>        if (h == head)                   // loop if head changed<br>            break;<br>    }<br>}</p>
<p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>
<ol>
<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>
<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>
</ol>
<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？ 因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。 for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/04/21/abstractqueuedsynchronizer-e4-ba-8c-condition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/21/abstractqueuedsynchronizer-e4-ba-8c-condition/" class="post-title-link" itemprop="url">AbstractQueuedSynchronizer(二)-Condition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-21 10:29:58" itemprop="dateCreated datePublished" datetime="2018-04-21T10:29:58+08:00">2018-04-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来看看 Condition 的使用场景，Condition 经常可以用在<strong>生产者-消费者</strong>的场景中，请看 Doug Lea 给出的这个例子：</p>
<p>import java.util.concurrent.locks.Condition;<br>import java.util.concurrent.locks.Lock;<br>import java.util.concurrent.locks.ReentrantLock;</p>
<p>class BoundedBuffer {<br>    final Lock lock = new ReentrantLock();<br>    // condition 依赖于 lock 来产生<br>    final Condition notFull = lock.newCondition();<br>    final Condition notEmpty = lock.newCondition();</p>
<pre><code>final Object\[\] items = new Object\[100\];
int putptr, takeptr, count;

// 生产
public void put(Object x) throws InterruptedException {
    lock.lock();
    try {
        while (count == items.length)
            notFull.await();  // 队列已满，等待，直到 not full 才能继续生产
        items\[putptr\] = x;
        if (++putptr == items.length) putptr = 0;
        ++count;
        notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去
    } finally {
        lock.unlock();
    }
}

// 消费
public Object take() throws InterruptedException {
    lock.lock();
    try {
        while (count == 0)
            notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费
        Object x = items\[takeptr\];
        if (++takeptr == items.length) takeptr = 0;
        --count;
        notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去
        return x;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>}</p>
<p><em>（<strong>ArrayBlockingQueue</strong> 采用这种方式实现了生产者-消费者，所以请只把这个例子当做学习例子，实际生产中可以直接使用 ArrayBlockingQueue）</em> 我们常用 obj.wait()，obj.notify() 或 obj.notifyAll() 来实现相似的功能，但是，它们是基于对象的监视器锁的。 而这里说的 Condition 是基于 ReentrantLock 实现的，而 ReentrantLock 是依赖于 AbstractQueuedSynchronizer 实现的。 在往下看之前，读者心里要有一个整体的概念。condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，都必须获取到锁才能进行操作。 每个 ReentrantLock 实例可以通过调用多次 newCondition 产生多个 ConditionObject 的实例：</p>
<p>final ConditionObject newCondition() {<br>    return new ConditionObject();<br>}</p>
<p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p>
<p>public class ConditionObject implements Condition, java.io.Serializable {<br>        private static final long serialVersionUID = 1173984872572414699L;<br>        // 条件队列的第一个节点<br>          // 不要管这里的关键字 transient，是不参与序列化的意思<br>        private transient Node firstWaiter;<br>        // 条件队列的最后一个节点<br>        private transient Node lastWaiter;<br>        ……</p>
<p>AQS 里面有一个一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列。这里我们引入另一个概念，叫<strong>条件队列</strong>（condition queue），一张简单的图用来说明这个。 这里的阻塞队列如果叫做同步队列（sync queue）其实比较贴切。记住这里的两个概念，<strong>阻塞队列</strong>和<strong>条件队列</strong>。<img src="https://zhongmin.me/wp-content/uploads/2018/04/SYMDV88@LFJN_836-933x640.png" alt> 这里，我们简单回顾下 Node 的属性：</p>
<p>volatile int waitStatus; // 可取值 0、CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)<br>volatile Node prev;<br>volatile Node next;<br>volatile Thread thread;<br>Node nextWaiter;</p>
<p>prev 和 next 用于实现阻塞队列的双向链表，nextWaiter 用于实现条件队列的单向链表 基本上，把这张图看懂，你也就知道 condition 的处理流程了。所以，我先简单解释下这图，然后再具体地解释代码实现。</p>
<ol>
<li><p>我们知道一个 ReentrantLock 实例可以通过多次调用 newCondition() 来产生多个 Condition 实例，这里对应 condition1 和 condition2。注意，ConditionObject 只有两个属性 firstWaiter 和 lastWaiter；</p>
</li>
<li><p>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 condition1.await() 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</p>
</li>
<li>调用 condition1.signal() 会将condition1 对应的<strong>条件队列</strong>的 firstWaiter 移到<strong>阻塞队列</strong>的队尾，等待获取锁，获取锁后 await 方法返回，继续往下执行。</li>
</ol>
<p>我这里说的 1、2、3 是最简单的流程，没有考虑中断、signalAll、还有带有超时参数的 await 方法等，不过把这里弄懂是这节的主要目的。 同时，从图中也可以很直观地看出，哪些操作是线程安全的，哪些操作是线程不安全的。 这个图看懂后，下面的代码分析就简单了。 接下来，我们一步步按照流程来走代码分析，我们先来看看 wait 方法</p>
<p>/ 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()<br>// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断<br>public final void await() throws InterruptedException {<br>    if (Thread.interrupted())<br>        throw new InterruptedException();<br>    // 添加到 condition 的条件队列中<br>    Node node = addConditionWaiter();<br>    // 释放锁，返回值是释放锁之前的 state 值<br>    int savedState = fullyRelease(node);<br>    int interruptMode = 0;<br>    // 这里退出循环有两种情况，之后再仔细分析<br>    // 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了<br>    // 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断<br>    while (!isOnSyncQueue(node)) {<br>        LockSupport.park(this);<br>        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>            break;<br>    }<br>    // 被唤醒后，将进入阻塞队列，等待获取锁<br>    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    if (node.nextWaiter != null) // clean up if cancelled<br>        unlinkCancelledWaiters();<br>    if (interruptMode != 0)<br>        reportInterruptAfterWait(interruptMode);<br>}</p>
<h3 id="1-将节点加入到条件队列"><a href="#1-将节点加入到条件队列" class="headerlink" title="1. 将节点加入到条件队列"></a>1. 将节点加入到条件队列</h3><p>addConditionWaiter() 是将当前节点加入到条件队列，看图我们知道，这种条件队列内的操作是线程安全的。</p>
<p>// 将当前线程对应的节点入队，插入队尾<br>private Node addConditionWaiter() {<br>    Node t = lastWaiter;<br>    // 如果条件队列的最后一个节点取消了，将其清除出去<br>    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {<br>        // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    }<br>    Node node = new Node(Thread.currentThread(), Node.CONDITION);<br>    // 如果队列为空<br>    if (t == null)<br>        firstWaiter = node;<br>    else<br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    return node;<br>}</p>
<p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。 当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p>
<p>// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去<br>// 纯属链表操作，很好理解，看不懂多看几遍就可以了<br>private void unlinkCancelledWaiters() {<br>    Node t = firstWaiter;<br>    Node trail = null;<br>    while (t != null) {<br>        Node next = t.nextWaiter;<br>        // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的<br>        if (t.waitStatus != Node.CONDITION) {<br>            t.nextWaiter = null;<br>            if (trail == null)<br>                firstWaiter = next;<br>            else<br>                trail.nextWaiter = next;<br>            if (next == null)<br>                lastWaiter = trail;<br>        }<br>        else<br>            trail = t;<br>        t = next;<br>    }<br>}</p>
<p>在addWaiter 方法中，有一个 unlinkCancelledWaiters() 方法，该方法用于清除队列中已经取消等待的节点。 当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p>
<p>// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去<br>// 纯属链表操作，很好理解，看不懂多看几遍就可以了<br>private void unlinkCancelledWaiters() {<br>    Node t = firstWaiter;<br>    Node trail = null;<br>    while (t != null) {<br>        Node next = t.nextWaiter;<br>        // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的<br>        if (t.waitStatus != Node.CONDITION) {<br>            t.nextWaiter = null;<br>            if (trail == null)<br>                firstWaiter = next;<br>            else<br>                trail.nextWaiter = next;<br>            if (next == null)<br>                lastWaiter = trail;<br>        }<br>        else<br>            trail = t;<br>        t = next;<br>    }<br>}</p>
<h3 id="2-完全释放独占锁"><a href="#2-完全释放独占锁" class="headerlink" title="2. 完全释放独占锁"></a>2. 完全释放独占锁</h3><p>回到 wait 方法，节点入队了以后，会调用 <code>int savedState = fullyRelease(node);</code> 方法释放锁，注意，这里是完全释放独占锁，因为 ReentrantLock 是可以重入的。</p>
<p>// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值<br>// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。<br>//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1<br>//         相应的，如果 lock 重入了 n 次，savedState == n<br>// 如果这个方法失败，会将节点设置为”取消”状态，并抛出异常 IllegalMonitorStateException<br>final int fullyRelease(Node node) {<br>    boolean failed = true;<br>    try {<br>        int savedState = getState();<br>        // 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0<br>        if (release(savedState)) {<br>            failed = false;<br>            return savedState;<br>        } else {<br>            throw new IllegalMonitorStateException();<br>        }<br>    } finally {<br>        if (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    }<br>}</p>
<h3 id="3-等待进入阻塞队列"><a href="#3-等待进入阻塞队列" class="headerlink" title="3. 等待进入阻塞队列"></a>3. 等待进入阻塞队列</h3><p>释放掉锁以后，接下来是这段，这边会自旋，如果发现自己还没到阻塞队列，那么挂起，等待被转移到阻塞队列。</p>
<p>int interruptMode = 0;<br>while (!isOnSyncQueue(node)) {<br>    // 线程挂起<br>    LockSupport.park(this);</p>
<pre><code>if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
    break;
</code></pre><p>}</p>
<p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p>
<p>// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION<br>// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，<br>// 这个方法就是判断 node 是否已经移动到阻塞队列了<br>final boolean isOnSyncQueue(Node node) {<br>    // 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到<br>    // 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中<br>    // 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列<br>    if (node.waitStatus == Node.CONDITION || node.prev == null)<br>        return false;<br>    // 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了<br>    if (node.next != null)<br>        return true;</p>
<pre><code>// 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列

// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。
// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，
// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。

// 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的
return findNodeFromTail(node);
</code></pre><p>}</p>
<p>// 从同步队列的队尾往前遍历，如果找到，返回 true<br>private boolean findNodeFromTail(Node node) {<br>    Node t = tail;<br>    for (;;) {<br>        if (t == node)<br>            return true;<br>        if (t == null)<br>            return false;<br>        t = t.prev;<br>    }<br>}</p>
<p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p>
<h3 id="4-signal-唤醒线程，转移到阻塞队列"><a href="#4-signal-唤醒线程，转移到阻塞队列" class="headerlink" title="4. signal 唤醒线程，转移到阻塞队列"></a>4. signal 唤醒线程，转移到阻塞队列</h3><p>为了大家理解，这里我们先看唤醒操作，因为刚刚到 LockSupport.park(this); 把线程挂起了，等待唤醒。 唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p>
<p>// 唤醒等待了最久的线程<br>// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列<br>public final void signal() {<br>    // 调用 signal 方法的线程必须持有当前的独占锁<br>    if (!isHeldExclusively())<br>        throw new IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    if (first != null)<br>        doSignal(first);<br>}</p>
<p>// 从条件队列队头往后遍历，找出第一个需要转移的 node<br>// 因为前面我们说过，有些线程会取消排队，但是还在队列中<br>private void doSignal(Node first) {<br>    do {<br>          // 将 firstWaiter 指向 first 节点后面的第一个<br>        // 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null<br>        if ( (firstWaiter = first.nextWaiter) == null)<br>            lastWaiter = null;<br>        // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉<br>        first.nextWaiter = null;<br>    } while (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != null);<br>      // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推<br>}</p>
<p>// 将节点从条件队列转移到阻塞队列<br>// true 代表成功转移<br>// false 代表在 signal 之前，节点已经取消了<br>final boolean transferForSignal(Node node) {</p>
<pre><code>// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，
// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点
// 否则，将 waitStatus 置为 0
if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
    return false;

// enq(node): 自旋进入阻塞队列的队尾
// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点
Node p = enq(node);
int ws = p.waitStatus;
// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释
// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)
if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
    // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节
    LockSupport.unpark(node.thread);
return true;
</code></pre><p>}</p>
<p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。 假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>
<h3 id="5-唤醒后检查中断状态"><a href="#5-唤醒后检查中断状态" class="headerlink" title="5. 唤醒后检查中断状态"></a>5. 唤醒后检查中断状态</h3><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。 等线程从挂起中恢复过来，继续往下看</p>
<p>int interruptMode = 0;<br>while (!isOnSyncQueue(node)) {<br>    // 线程挂起<br>    LockSupport.park(this);</p>
<pre><code>if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
    break;
</code></pre><p>}</p>
<p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>
<ul>
<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li>
<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>
<li>0 ：说明在 await 期间，没有发生中断</li>
</ul>
<p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p>
<ol>
<li>常规路劲。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li>
<li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li>
<li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>
<li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li>
</ol>
<p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p>
<p>// 1. 如果在 signal 之前已经中断，返回 THROW_IE<br>// 2. 如果是 signal 之后中断，返回 REINTERRUPT<br>// 3. 没有发生中断，返回 0<br>private int checkInterruptWhileWaiting(Node node) {<br>    return Thread.interrupted() ?<br>        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>        0;<br>}</p>
<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。 看看怎么判断是 signal 之前还是之后发生的中断：</p>
<p>// 只有线程处于中断状态，才会调用此方法<br>// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列<br>// 返回 true：如果此线程在 signal 之前被取消，<br>final boolean transferAfterCancelledWait(Node node) {<br>    // 用 CAS 将节点状态设置为 0<br>    // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0<br>    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {<br>        // 将节点放入阻塞队列<br>        // 这里我们看到，即使中断了，依然会转移到阻塞队列<br>        enq(node);<br>        return true;<br>    }</p>
<pre><code>// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0
// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成
// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断
while (!isOnSyncQueue(node))
    Thread.yield();
return false;
</code></pre><p>}</p>
<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。 到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功</p>
<h3 id="6-获取独占锁"><a href="#6-获取独占锁" class="headerlink" title="6. 获取独占锁"></a>6. 获取独占锁</h3><p>while 循环出来以后，下面是这段代码：</p>
<p>if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>    interruptMode = REINTERRUPT;</p>
<p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。 这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。 注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。 继续往下：</p>
<p>if (node.nextWaiter != null) // clean up if cancelled<br>    unlinkCancelledWaiters();<br>if (interruptMode != 0)<br>    reportInterruptAfterWait(interruptMode);</p>
<p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。 可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。 之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p>
<h3 id="7-处理中断状态"><a href="#7-处理中断状态" class="headerlink" title="7. 处理中断状态"></a>7. 处理中断状态</h3><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p>
<ul>
<li>0：什么都不做。</li>
<li>THROW_IE：await 方法抛出 InterruptedException 异常</li>
<li>REINTERRUPT：重新中断当前线程 </li>
</ul>
<p>private void reportInterruptAfterWait(int interruptMode)<br>    throws InterruptedException {<br>    if (interruptMode == THROW_IE)<br>        throw new InterruptedException();<br>    else if (interruptMode == REINTERRUPT)<br>        selfInterrupt();<br>}</p>
<h3 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h3><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p>
<p>ublic final long awaitNanos(long nanosTimeout)<br>                  throws InterruptedException<br>public final boolean awaitUntil(Date deadline)<br>                throws InterruptedException<br>public final boolean await(long time, TimeUnit unit)<br>                throws InterruptedException</p>
<p>这三个方法都差不多，我们就挑一个出来看看吧：</p>
<p>public final boolean await(long time, TimeUnit unit)<br>        throws InterruptedException {<br>    // 等待这么多纳秒<br>    long nanosTimeout = unit.toNanos(time);<br>    if (Thread.interrupted())<br>        throw new InterruptedException();<br>    Node node = addConditionWaiter();<br>    int savedState = fullyRelease(node);<br>    // 当前时间 + 等待时长 = 过期时间<br>    final long deadline = System.nanoTime() + nanosTimeout;<br>    // 用于返回 await 是否超时<br>    boolean timedout = false;<br>    int interruptMode = 0;<br>    while (!isOnSyncQueue(node)) {<br>        // 时间到啦<br>        if (nanosTimeout &lt;= 0L) {<br>            // 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法<br>            // 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功<br>            // 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛<br>            timedout = transferAfterCancelledWait(node);<br>            break;<br>        }<br>        // spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒<br>        // 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好<br>        if (nanosTimeout &gt;= spinForTimeoutThreshold)<br>            LockSupport.parkNanos(this, nanosTimeout);<br>        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>            break;<br>        // 得到剩余时间<br>        nanosTimeout = deadline - System.nanoTime();<br>    }<br>    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    if (node.nextWaiter != null)<br>        unlinkCancelledWaiters();<br>    if (interruptMode != 0)<br>        reportInterruptAfterWait(interruptMode);<br>    return !timedout;<br>}</p>
<p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p>
<h3 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h3><p>关于 Condition 最后一小节了。</p>
<p>public final void awaitUninterruptibly() {<br>    Node node = addConditionWaiter();<br>    int savedState = fullyRelease(node);<br>    boolean interrupted = false;<br>    while (!isOnSyncQueue(node)) {<br>        LockSupport.park(this);<br>        if (Thread.interrupted())<br>            interrupted = true;<br>    }<br>    if (acquireQueued(node, savedState) || interrupted)<br>        selfInterrupt();<br>}</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/04/15/e7-90-86-e8-a7-a3abstractqueuedsynchronizer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/15/e7-90-86-e8-a7-a3abstractqueuedsynchronizer/" class="post-title-link" itemprop="url">理解AbstractQueuedSynchronizer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-15 16:29:34" itemprop="dateCreated datePublished" datetime="2018-04-15T16:29:34+08:00">2018-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AbstractQueuedSynchronizer简介"><a href="#AbstractQueuedSynchronizer简介" class="headerlink" title="AbstractQueuedSynchronizer简介"></a>AbstractQueuedSynchronizer简介</h2><p>AbstractQueuedSynchronizer提供了一个FIFO队列，可以看做是一个可以用来实现锁以及其他需要同步功能的框架。这里简称该类为AQS。AQS的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。例如ReentrantLock，CountDownLatch等。 本篇文章基于JDK1.8来介绍，该类有许多实现类：<img src="http://zhongmin.me/wp-content/uploads/2018/04/P9C0R37@6U51XH_5A6PR2H3.png" alt> 其中，我们最常用的大概就是ReentrantLock和CountDownLatch了。ReentrantLock提供了对代码块的并发访问控制，也就是锁，说是锁，但其实并没有用到关键字<code>synchronized</code>，这么神奇？其实其内部就是基于同步器来实现的，本文结合ReentrantLock的使用来分析同步器独占锁的原理。</p>
<h2 id="AQS的两种功能"><a href="#AQS的两种功能" class="headerlink" title="AQS的两种功能"></a>AQS的两种功能</h2><p>从使用上来说，AQS的功能可以分为两种：独占和共享。对于这两种功能，有一个很常用的类：ReentrantReadWriteLock，其就是通过两个内部类来分别实现了这两种功能，提供了读锁和写锁的功能。但子类实现时，只能实现其中的一种功能，即要么是独占功能，要么是共享功能。 对于独占功能，例如如下代码：</p>
<p>ReentrantLock lock = new ReentrantLock();<br>…<br>public void function(){</p>
<pre><code>lock.lock();
try {

// do something...


} finally {
    lock.unlock();
}
</code></pre><p>}</p>
<p>这个很好理解，通过ReentrantLock来保证在<code>lock.lock()</code>之后的代码在同一时刻只能有一个线程来执行，其余的线程将会被阻塞，直到该线程执行了<code>lock.unlock()</code>。这就是一个独占锁的功能。 对于共享功能，例如如下代码：</p>
<p>ReentrantReadWriteLock lock = new ReentrantReadWriteLock();<br>…<br>public void function(){</p>
<pre><code>lock.readLock().lock();
try {

// do something...


} finally {
    lock.readLock().unlock();
}
</code></pre><p>}</p>
<p>代码中的<code>lock</code>是<code>ReentrantReadWriteLock</code>类的实例，而<code>lock.readLock()</code>为获取其中的读锁，即共享锁，使用方式并无差别，但和独占锁是有区别的：</p>
<ul>
<li>读锁与读锁可以共享</li>
<li>读锁与写锁不可以共享（排他）</li>
<li>写锁与写锁不可以共享（排他）</li>
</ul>
<h2 id="AQS独占锁的内部实现"><a href="#AQS独占锁的内部实现" class="headerlink" title="AQS独占锁的内部实现"></a>AQS独占锁的内部实现</h2><h3 id="AQS的主要数据结构"><a href="#AQS的主要数据结构" class="headerlink" title="AQS的主要数据结构"></a>AQS的主要数据结构</h3><p>由于使用AQS可以实现锁的功能，那么下面就要分析一下究竟是如何实现的。 AQS内部维护着一个FIFO的队列，该队列就是用来实现线程的并发访问控制。队列中的元素是一个Node类型的节点，Node的主要属性如下：</p>
<p>static final class Node {<br>    int waitStatus;<br>    Node prev;<br>    Node next;<br>    Node nextWaiter;<br>    Thread thread;<br>}</p>
<ol>
<li><em>waitStatus</em>：表示节点的状态，其中包含的状态有：<ul>
<li><em>CANCELLED</em>：值为1，表示当前节点被取消；</li>
<li><em>SIGNAL</em>：值为-1，表示当前节点的的后继节点将要或者已经被阻塞，在当前节点释放的时候需要unpark后继节点；</li>
<li><em>CONDITION</em>：值为-2，表示当前节点在等待condition，即在condition队列中；</li>
<li><em>PROPAGATE</em>：值为-3，表示releaseShared需要被传播给后续节点（仅在共享模式下使用）；</li>
<li>_0_：无状态，表示当前节点在队列中等待获取锁。</li>
</ul>
</li>
<li><em>prev</em>：前继节点；</li>
<li><em>next</em>：后继节点；</li>
<li><em>nextWaiter</em>：存储condition队列中的后继节点；</li>
<li><em>thread</em>：当前线程。</li>
</ol>
<p>其中，队列里还有一个<code>head</code>节点和一个<code>tail</code>节点，分别表示头结点和尾节点，其中头结点不存储Thread，仅保存next结点的引用。 AQS中有一个<code>state</code>变量，该变量对不同的子类实现具有不同的意义，对ReentrantLock来说，它表示加锁的状态：</p>
<ul>
<li>无锁时state=0，有锁时state&gt;0；</li>
<li>第一次加锁时，将state设置为1；</li>
<li>由于ReentrantLock是可重入锁，所以持有锁的线程可以多次加锁，经过判断加锁线程就是当前持有锁的线程时（即<code>exclusiveOwnerThread==Thread.currentThread()</code>），即可加锁，每次加锁都会将state的值+1，state等于几，就代表当前持有锁的线程加了几次锁;</li>
<li>解锁时每解一次锁就会将state减1，state减到0后，锁就被释放掉，这时其它线程可以加锁；</li>
<li>当持有锁的线程释放锁以后，如果是等待队列获取到了加锁权限，则会在等待队列头部取出第一个线程去获取锁，获取锁的线程会被移出队列；</li>
</ul>
<p><code>state</code>变量定义如下：</p>
<p>/**<br> * The synchronization state.<br> */<br>private volatile int state;</p>
<h3 id="ReentrantLock类的结构"><a href="#ReentrantLock类的结构" class="headerlink" title="ReentrantLock类的结构"></a>ReentrantLock类的结构</h3><p>下面通过ReentrantLock的实现进一步分析重入锁的实现。 首先看一下lock方法：</p>
<p>public void lock() {<br>    sync.lock();<br>}</p>
<p>该方法调用了<code>sync</code>实例的lock方法，这里要说明一下ReentrantLock中的几个内部类：</p>
<ul>
<li>Sync</li>
<li>FairSync</li>
<li>NonfairSync</li>
</ul>
<p>对于ReentrantLock，有两种获取锁的模式：公平锁和非公平锁。所以对应有两个内部类，都继承自Sync。而Sync继承自AQS：<img src="http://zhongmin.me/wp-content/uploads/2018/04/5L0H6ELZWKTDMGRAM6.png" alt> 本文主要通过公平锁来介绍，看一下FairSync的定义：</p>
<p>/**<br> * Sync object for fair locks<br> <em>/<br>static final class FairSync extends Sync {<br>    private static final long serialVersionUID = -3000897897090466540L;<br>    final void lock() {<br>        acquire(1);<br>    }<br>    /\</em>*<br>     * Fair version of tryAcquire.  Don’t grant access unless<br>     * recursive call or no waiters or is first.<br>     <em>/<br>    protected final boolean tryAcquire(int acquires) {<br>        final Thread current = Thread.currentThread();<br>        // 获取state<br>        int c = getState();<br>        // state=0表示当前队列中没有线程被加锁<br>        if (c == 0) {<br>            /\</em><br>             * 首先判断是否有前继结点，如果没有则当前队列中还没有其他线程；<br>             * 设置状态为acquires，即lock方法中写死的1（这里为什么不直接setState？因为可能同时有多个线程同时在执行到此处，所以用CAS来执行）；<br>             * 设置当前线程独占锁。<br>             <em>/<br>            if (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(0, acquires)) {<br>                setExclusiveOwnerThread(current);<br>                return true;<br>            }<br>        }<br>        /\</em><br>         * 如果state不为0，表示已经有线程独占锁了，这时还需要判断独占锁的线程是否是当前的线程，原因是由于ReentrantLock为可重入锁；<br>         * 如果独占锁的线程是当前线程，则将状态加1，并setState;<br>         * 这里为什么不用compareAndSetState？因为独占锁的线程已经是当前线程，不需要通过CAS来设置。<br>         */<br>        else if (current == getExclusiveOwnerThread()) {<br>            int nextc = c + acquires;<br>            if (nextc &lt; 0)<br>                throw new Error(“Maximum lock count exceeded”);<br>            setState(nextc);<br>            return true;<br>        }<br>        return false;<br>    }<br>}</p>
<h3 id="AQS获取独占锁的实现"><a href="#AQS获取独占锁的实现" class="headerlink" title="AQS获取独占锁的实现"></a>AQS获取独占锁的实现</h3><h4 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h4><p><code>acquire</code>是AQS中的方法，代码如下：</p>
<p>public final void acquire(int arg) {<br>    if (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>}</p>
<p>该方法主要工作如下：</p>
<ol>
<li>尝试获取独占锁；</li>
<li>获取成功则返回，否则执行步骤3;</li>
<li>addWaiter方法将当前线程封装成Node对象，并添加到队列尾部；</li>
<li>自旋获取锁，并判断中断标志位。如果中断标志位为<code>true</code>，执行步骤5，否则返回；</li>
<li>设置线程中断。</li>
</ol>
<h4 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h4><p><code>tryAcquire</code>方法在FairSync中已经说明，它重写了AQS中的方法，在AQS中它的定义如下：</p>
<p>protected boolean tryAcquire(int arg) {<br>    throw new UnsupportedOperationException();<br>}</p>
<p>既然该方法需要子类来实现，为什么不使用<code>abstract</code>来修饰呢？上文中提到过，AQS有两种功能：独占和共享，而且子类只能实现其一种功能，所以，如果使用<code>abstract</code>来修饰，那么每个子类都需要同时实现两种功能的方法，这对子类来说不太友好，所以没有使用<code>abstract</code>来修饰。 该方法是在ReentrantLock中的FairSync和NonfairSync的两个内部类来实现的，这里以FairSysc-公平锁来说明:</p>
<p>protected final boolean tryAcquire(int acquires) {<br>    final Thread current = Thread.currentThread();<br>    int c = getState();<br>    if (c == 0) {<br>        if (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(0, acquires)) {<br>            setExclusiveOwnerThread(current);<br>            return true;<br>        }<br>    }<br>    else if (current == getExclusiveOwnerThread()) {<br>        int nextc = c + acquires;<br>        if (nextc &lt; 0)<br>            throw new Error(“Maximum lock count exceeded”);<br>        setState(nextc);<br>        return true;<br>    }<br>    return false;<br>}</p>
<h4 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h4><p>看下addWaiter方法的定义：</p>
<p>private Node addWaiter(Node mode) {<br>    // 根据当前线程创建一个Node对象<br>    Node node = new Node(Thread.currentThread(), mode);<br>    // Try the fast path of enq; backup to full enq on failure<br>    Node pred = tail;<br>    // 判断tail是否为空，如果为空表示队列是空的，直接enq<br>    if (pred != null) {<br>        node.prev = pred;<br>        // 这里尝试CAS来设置队尾，如果成功则将当前节点设置为tail，否则enq<br>        if (compareAndSetTail(pred, node)) {<br>            pred.next = node;<br>            return node;<br>        }<br>    }<br>    enq(node);<br>    return node;<br>}</p>
<p>该方法就是根据当前线程创建一个Node，然后添加到队列尾部。</p>
<h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><p>private Node enq(final Node node) {<br>    // 重复直到成功<br>    for (;;) {<br>        Node t = tail;<br>        // 如果tail为null，则必须创建一个Node节点并进行初始化<br>        if (t == null) { // Must initialize<br>            if (compareAndSetHead(new Node()))<br>                tail = head;<br>        } else {<br>            node.prev = t;<br>            // 尝试CAS来设置队尾<br>            if (compareAndSetTail(t, node)) {<br>                t.next = node;<br>                return t;<br>            }<br>        }<br>    }<br>}</p>
<h4 id="acquireQueued方法"><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h4><p>该方法的功能是循环的尝试获取锁，直到成功为止，最后返回中断标志位。</p>
<p>final boolean acquireQueued(final Node node, int arg) {<br>    boolean failed = true;<br>    try {<br>        // 中断标志位<br>        boolean interrupted = false;<br>        for (;;) {<br>            // 获取前继节点<br>            final Node p = node.predecessor();<br>            // 如果前继节点是head，则尝试获取<br>            if (p == head &amp;&amp; tryAcquire(arg)) {<br>                // 设置head为当前节点（head中不包含thread）<br>                setHead(node);<br>                // 清除之前的head<br>                p.next = null; // help GC<br>                failed = false;<br>                return interrupted;<br>            }<br>            // 如果p不是head或者获取锁失败，判断是否需要进行park<br>            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = true;<br>        }<br>    } finally {<br>        if (failed)<br>            cancelAcquire(node);<br>    }<br>}</p>
<p>这里有几个问题很重要：</p>
<ul>
<li>什么条件下需要park？</li>
<li>为什么要判断中断状态？</li>
<li>死循环不会引起CPU使用率飙升？</li>
</ul>
<p>下面分别来分析一下。 <strong>什么条件下需要park？</strong> 看下<code>shouldParkAfterFailedAcquire</code>方法的代码：</p>
<p>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br>    int ws = pred.waitStatus;<br>    if (ws == Node.SIGNAL)<br>        /*<br>         * This node has already set status asking a release<br>         * to signal it, so it can safely park.<br>         <em>/<br>        return true;<br>    if (ws &gt; 0) {<br>        /\</em><br>         * Predecessor was cancelled. Skip over predecessors and<br>         * indicate retry.<br>         <em>/<br>        do {<br>            node.prev = pred = pred.prev;<br>        } while (pred.waitStatus &gt; 0);<br>        pred.next = node;<br>    } else {<br>        /\</em><br>         * waitStatus must be 0 or PROPAGATE.  Indicate that we<br>         * need a signal, but don’t park yet.  Caller will need to<br>         * retry to make sure it cannot acquire before parking.<br>         */<br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    }<br>    return false;<br>}</p>
<ul>
<li>如果前一个节点的状态是<em>SIGNAL</em>，则需要park；</li>
<li>如果<code>ws &gt; 0</code>，表示已被取消，删除状态是已取消的节点；</li>
<li>其他情况，设置前继节点的状态为<em>SIGNAL</em>。</li>
</ul>
<p>可见，只有在前继节点的状态是<em>SIGNAL</em>时，需要park。第二种情况稍后会详细介绍。 <strong>为什么要判断中断状态？</strong> 首先要知道，acquireQueued方法中获取锁的方式是死循环，判断是否中断是在parkAndCheckInterrupt方法中实现的，看下该方法的代码：</p>
<p>private final boolean parkAndCheckInterrupt() {<br>    LockSupport.park(this);<br>    return Thread.interrupted();<br>}</p>
<p>非常简单，阻塞当前线程，然后返回线程的中断状态并复位中断状态。</p>
<blockquote>
<p>注意interrupted()方法的作用，该方法是获取线程的中断状态，并复位，也就是说，如果当前线程是中断状态，则第一次调用该方法获取的是<code>true</code>，第二次则是<code>false</code>。而isInterrupted()方法则只是返回线程的中断状态，不执行复位操作。</p>
</blockquote>
<p>如果acquireQueued执行完毕，返回中断状态，回到acquire方法中，根据返回的中断状态判断是否需要执行<code>Thread.currentThread().interrupt()</code>。 为什么要多做这一步呢？先判断中断状态，然后复位，如果之前线程是中断状态，再进行中断？ 这里就要介绍一下park方法了。park方法是Unsafe类中的方法，与之对应的是unpark方法。简单来说，当前线程如果执行了park方法，也就是阻塞了当前线程，反之，unpark就是唤醒一个线程。 具体的说明请参考<a href="http://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/28126139</a> park与wait的作用类似，但是对中断状态的处理并不相同。如果当前线程不是中断的状态，park与wait的效果是一样的；如果一个线程是中断的状态，这时执行wait方法会报<code>java.lang.IllegalMonitorStateException</code>，而执行park时并不会报异常，而是直接返回。 所以，知道了这一点，就可以知道为什么要进行中断状态的复位了：</p>
<ul>
<li>如果当前线程是非中断状态，则在执行park时被阻塞，这是返回中断状态是<code>false</code>；</li>
<li>如果当前线程是中断状态，则park方法不起作用，会立即返回，然后parkAndCheckInterrupt方法会获取中断的状态，也就是<code>true</code>，并复位；</li>
<li>再次执行循环的时候，由于在前一步已经把该线程的中断状态进行了复位，则再次调用park方法时会阻塞。</li>
</ul>
<p>所以，这里判断线程中断的状态实际上是为了不让循环一直执行，要让当前线程进入阻塞的状态。想象一下，如果不这样判断，前一个线程在获取锁之后执行了很耗时的操作，那么岂不是要一直执行该死循环？这样就造成了CPU使用率飙升，这是很严重的后果。 <strong>死循环不会引起CPU使用率飙升？</strong> 上面已经说明。</p>
<h4 id="cancelAcquire方法"><a href="#cancelAcquire方法" class="headerlink" title="cancelAcquire方法"></a>cancelAcquire方法</h4><p>在acquireQueued方法的finally语句块中，如果在循环的过程中出现了异常，则执行cancelAcquire方法，用于将该节点标记为取消状态。该方法代码如下：</p>
<p>private void cancelAcquire(Node node) {<br>    // Ignore if node doesn’t exist<br>    if (node == null)<br>        return;<br>    // 设置该节点不再关联任何线程<br>    node.thread = null;<br>    // Skip cancelled predecessors<br>    // 通过前继节点跳过取消状态的node<br>    Node pred = node.prev;<br>    while (pred.waitStatus &gt; 0)<br>        node.prev = pred = pred.prev;<br>    // predNext is the apparent node to unsplice. CASes below will<br>    // fail if not, in which case, we lost race vs another cancel<br>    // or signal, so no further action is necessary.<br>    // 获取过滤后的前继节点的后继节点<br>    Node predNext = pred.next;<br>    // Can use unconditional write instead of CAS here.<br>    // After this atomic step, other Nodes can skip past us.<br>    // Before, we are free of interference from other threads.<br>    // 设置状态为取消状态<br>    node.waitStatus = Node.CANCELLED;<br>    /*<br>     * If we are the tail, remove ourselves.<br>     * 1.如果当前节点是tail：<br>     * 尝试更新tail节点，设置tail为pred；<br>     * 更新失败则返回，成功则设置tail的后继节点为null<br>     <em>/<br>    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {<br>        compareAndSetNext(pred, predNext, null);<br>    } else {<br>        // If successor needs signal, try to set pred’s next-link<br>        // so it will get one. Otherwise wake it up to propagate.<br>        int ws;<br>        /\</em><br>         * 2.如果当前节点不是head的后继节点：<br>         * 判断当前节点的前继节点的状态是否是SIGNAL，如果不是则尝试设置前继节点的状态为SIGNAL；<br>         * 上面两个条件如果有一个返回true，则再判断前继节点的thread是否不为空；<br>         * 若满足以上条件，则尝试设置当前节点的前继节点的后继节点为当前节点的后继节点，也就是相当于将当前节点从队列中删除<br>         */<br>        if (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != null) {<br>            Node next = node.next;<br>            if (next != null &amp;&amp; next.waitStatus &lt;= 0)<br>                compareAndSetNext(pred, predNext, next);<br>        } else {<br>            // 3.如果是head的后继节点或者状态判断或设置失败，则唤醒当前节点的后继节点<br>            unparkSuccessor(node);<br>        }<br>        node.next = node; // help GC<br>    }<br>}</p>
<p>该方法中执行的过程有些复杂，首先是要获取当前节点的前继节点，如果前继节点的状态不是取消状态（即<code>pred.waitStatus &gt; 0</code>），则向前遍历队列，直到遇到第一个<code>waitStatus &lt;= 0</code>的节点，并把当前节点的前继节点设置为该节点，然后设置当前节点的状态为取消状态。 接下来的工作可以分为3种情况：</p>
<ul>
<li>当前节点是tail；</li>
<li>当前节点不是head的后继节点（即队列的第一个节点，不包括head），也不是tail；</li>
<li>当前节点是head的后继节点。</li>
</ul>
<p>我们依次来分析一下： <strong>当前节点是tail</strong> 这种情况很简单，因为tail是队列的最后一个节点，如果该节点需要取消，则直接把该节点的前继节点的next指向null，也就是把当前节点移除队列。出队的过程如下：<img src="http://zhongmin.me/wp-content/uploads/2018/04/SG2BEN097MZ8MDA-372x250.png" alt> 注意：经验证，这里并没有设置node的prev为null。 <strong>当前节点不是head的后继节点，也不是tail</strong><img src="http://zhongmin.me/wp-content/uploads/2018/04/@LLH5CL7KS@6W3DLLGLL3-375x224.png" alt> 这里将node的前继节点的next指向了node的后继节点，真正执行的代码就是如下一行： <code>compareAndSetNext(pred, predNext, next);</code> <strong>当前节点是head的后继节点</strong><img src="http://zhongmin.me/wp-content/uploads/2018/04/Y@O1HVKPXFPOIO-353x250.png" alt> 这里直接unpark后继节点的线程，然后将next指向了自己。 这里可能会有疑问，既然要删除节点，为什么都没有对prev进行操作，而仅仅是修改了next？ 要明确的一点是，这里修改指针的操作都是CAS操作，在AQS中所有以<code>compareAndSet</code>开头的方法都是尝试更新，并不保证成功，图中所示的都是执行成功的情况。 那么在执行cancelAcquire方法时，当前节点的前继节点有可能已经执行完并移除队列了（参见<code>setHead</code>方法），所以在这里只能用CAS来尝试更新，而就算是尝试更新，也只能更新next，不能更新prev，因为prev是不确定的，否则有可能会导致整个队列的不完整，例如把prev指向一个已经移除队列的node。 什么时候修改prev呢？其实prev是由其他线程来修改的。回去看下shouldParkAfterFailedAcquire方法，该方法有这样一段代码：</p>
<p>do {<br>    node.prev = pred = pred.prev;<br>} while (pred.waitStatus &gt; 0);<br>pred.next = node;</p>
<p>该段代码的作用就是通过prev遍历到第一个不是取消状态的node，并修改prev。 这里为什么可以更新prev？因为shouldParkAfterFailedAcquire方法是在获取锁失败的情况下才能执行，因此进入该方法时，说明已经有线程获得锁了，并且在执行该方法时，当前节点之前的节点不会变化（因为只有当下一个节点获得锁的时候才会设置head），所以这里可以更新prev，而且不必用CAS来更新。</p>
<h3 id="AQS释放独占锁的实现"><a href="#AQS释放独占锁的实现" class="headerlink" title="AQS释放独占锁的实现"></a>AQS释放独占锁的实现</h3><p>释放通过unlock方法来实现：</p>
<p>public void unlock() {<br>    sync.release(1);<br>}</p>
<p>该方法调用了release方法，release是在AQS中定义的，看下release代码：</p>
<p>public final boolean release(int arg) {<br>    // 尝试释放锁<br>    if (tryRelease(arg)) {<br>        // 释放成功后unpark后继节点的线程<br>        Node h = head;<br>        if (h != null &amp;&amp; h.waitStatus != 0)<br>            unparkSuccessor(h);<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>这里首先尝试着去释放锁，成功了之后要去唤醒后继节点的线程，这样其他的线程才有机会去执行。 tryRelease代码如下：</p>
<p>protected boolean tryRelease(int arg) {<br>    throw new UnsupportedOperationException();<br>}</p>
<p>是不是和tryAcquire方法类似？该方法也需要被重写，在Sync类中的代码如下：</p>
<p>protected final boolean tryRelease(int releases) {<br>    // 这里是将锁的数量减1<br>    int c = getState() - releases;<br>    // 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常<br>    if (Thread.currentThread() != getExclusiveOwnerThread())<br>        throw new IllegalMonitorStateException();<br>    boolean free = false;<br>    // 由于重入的关系，不是每次释放锁c都等于0，<br>    // 直到最后一次释放锁时，才会把当前线程释放<br>    if (c == 0) {<br>        free = true;<br>        setExclusiveOwnerThread(null);<br>    }<br>    // 记录锁的数量<br>    setState(c);<br>    return free;<br>}</p>
<p>当前线程被释放之后，需要唤醒下一个节点的线程，通过unparkSuccessor方法来实现：</p>
<p>private void unparkSuccessor(Node node) {<br>    /*<br>     * If status is negative (i.e., possibly needing signal) try<br>     * to clear in anticipation of signalling.  It is OK if this<br>     * fails or if status is changed by waiting thread.<br>     <em>/<br>    int ws = node.waitStatus;<br>    if (ws &lt; 0)<br>        compareAndSetWaitStatus(node, ws, 0);<br>    /\</em><br>     * Thread to unpark is held in successor, which is normally<br>     * just the next node.  But if cancelled or apparently null,<br>     * traverse backwards from tail to find the actual<br>     * non-cancelled successor.<br>     */<br>    Node s = node.next;<br>    if (s == null || s.waitStatus &gt; 0) {<br>        s = null;<br>        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)<br>            if (t.waitStatus &lt;= 0)<br>                s = t;<br>    }<br>    if (s != null)<br>        LockSupport.unpark(s.thread);<br>}</p>
<p>主要功能就是要唤醒下一个线程，这里<code>s == null || s.waitStatus &gt; 0</code>判断后继节点是否为空或者是否是取消状态，然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点，至于为什么从尾部开始向前遍历，回想一下cancelAcquire方法的处理过程，cancelAcquire只是设置了next的变化，没有设置prev的变化，在最后有这样一行代码：<code>node.next = node</code>，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的。 到这里，通过ReentrantLock的lock和unlock来分析AQS独占锁的实现已经基本完成了，但ReentrantLock还有一个非公平锁NonfairSync。 其实NonfairSync和FairSync主要就是在获取锁的方式上不同，公平锁是按顺序去获取，而非公平锁是抢占式的获取，lock的时候先去尝试修改state变量，如果抢占成功，则获取到锁：</p>
<p>final void lock() {<br>    if (compareAndSetState(0, 1))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    else<br>        acquire(1);<br>}</p>
<p>非公平锁的tryAcquire方法调用了nonfairTryAcquire方法：</p>
<p>final boolean nonfairTryAcquire(int acquires) {<br>    final Thread current = Thread.currentThread();<br>    int c = getState();<br>    if (c == 0) {<br>        if (compareAndSetState(0, acquires)) {<br>            setExclusiveOwnerThread(current);<br>            return true;<br>        }<br>    }<br>    else if (current == getExclusiveOwnerThread()) {<br>        int nextc = c + acquires;<br>        if (nextc &lt; 0) // overflow<br>            throw new Error(“Maximum lock count exceeded”);<br>        setState(nextc);<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>该方法比公平锁的tryAcquire方法在第二个if判断中少了一个是否存在前继节点判断，FairSync中的tryAcquire代码中的这个if语句块如下：</p>
<p>if (!hasQueuedPredecessors() &amp;&amp;<br>    compareAndSetState(0, acquires)) {<br>    setExclusiveOwnerThread(current);<br>    return true;<br>}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从ReentrantLock出发，比较完整的分析了AQS内部独占锁的实现，总体来说实现的思路很清晰，就是使用了标志位+队列的方式来处理锁的状态，包括锁的获取，锁的竞争以及锁的释放。在AQS中，state可以表示锁的数量，也可以表示其他状态，state的含义由子类去定义，自己只是提供了对state的维护。AQS通过state来实现线程对资源的访问控制，而state具体的含义要在子类中定义。 AQS在队列的维护上的实现比较复杂，尤其是节点取消时队列的维护，这里并不是通过一个线程来完成的。同时，AQS中大量的使用CAS来实现更新，这种更新能够保证状态和队列的完整性。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/04/15/java-e7-9a-84locksupport-park-e5-ae-9e-e7-8e-b0-e5-88-86-e6-9e-90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/15/java-e7-9a-84locksupport-park-e5-ae-9e-e7-8e-b0-e5-88-86-e6-9e-90/" class="post-title-link" itemprop="url">Java的LockSupport.park()实现分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-15 14:40:37" itemprop="dateCreated datePublished" datetime="2018-04-15T14:40:37+08:00">2018-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ockSupport类是Java6(JSR166-JUC)引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p>
<p>public native void unpark(Thread jthread);<br>public native void park(boolean isAbsolute, long time);</p>
<p>isAbsolute参数是指明时间是绝对的，还是相对的。 仅仅两个简单的接口，就为上层提供了强大的同步原语。 先来解析下两个函数是做什么的。 unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。 比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。 <strong>注意，unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。</strong> 实际上，park函数即使没有“许可”，有时也会无理由地返回.</p>
<h2 id="park和unpark的灵活之处"><a href="#park和unpark的灵活之处" class="headerlink" title="park和unpark的灵活之处"></a>park和unpark的灵活之处</h2><p>上面已经提到，unpark函数可以先于park调用，这个正是它们的灵活之处。 <strong>一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！</strong> 考虑一下，两个线程同步，要如何处理？ 在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如<strong>线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。</strong>编程的时候就会很蛋疼。 另外，<strong>是调用notify，还是notifyAll？</strong> notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。 <strong>park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</strong></p>
<h2 id="HotSpot里park-unpark的实现"><a href="#HotSpot里park-unpark的实现" class="headerlink" title="HotSpot里park/unpark的实现"></a>HotSpot里park/unpark的实现</h2><p>每个java线程都有一个Parker实例，Parker类是这样定义的：</p>
<p>class Parker : public os::PlatformParker {<br>private:<br>  volatile int _counter ;<br>  …<br>public:<br>  void park(bool isAbsolute, jlong time);<br>  void unpark();<br>  …<br>}<br>class PlatformParker : public CHeapObj<mtinternal> {<br>  protected:<br>    pthread_mutex_t _mutex [1] ;<br>    pthread_cond_t  _cond  [1] ;<br>    …<br>}</mtinternal></p>
<p>可以看到Parker类实际上用Posix的mutex，condition来实现的。 在Parker类里的_counter字段，就是用来记录所谓的“许可”的。 当调用park时，先尝试直接能否直接拿到“许可”，即_counter&gt;0时，如果成功，则把_counter设置为0,并返回：</p>
<p>void Parker::park(bool isAbsolute, jlong time) {<br>  // Ideally we’d do something useful while spinning, such<br>  // as calling unpackTime().  </p>
<p>  // Optional fast-path check:<br>  // Return immediately if a permit is available.<br>  // We depend on Atomic::xchg() having full barrier semantics<br>  // since we are doing a lock-free update to _counter.<br>  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</p>
<p>如果不成功，则构造一个ThreadBlockInVM，然后检查_counter是不是&gt;0，如果是，则把_counter设置为0，unlock mutex并返回：</p>
<p>ThreadBlockInVM tbivm(jt);<br>if (_counter &gt; 0)  { // no wait needed<br>  _counter = 0;<br>  status = pthread_mutex_unlock(_mutex);</p>
<p>否则，再判断等待的时间，然后再调用pthread_cond_wait函数等待，如果等待返回，则把_counter设置为0，unlock mutex并返回：</p>
<p>if (time == 0) {<br>  status = pthread_cond_wait (_cond, _mutex) ;<br>}<br>_counter = 0 ;<br>status = pthread_mutex_unlock(_mutex) ;<br>assert_status(status == 0, status, “invariant”) ;<br>OrderAccess::fence();</p>
<p>当unpark时，则简单多了，直接设置_counter为1，再unlock mutext返回。如果_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程：</p>
<p>void Parker::unpark() {<br>  int s, status ;<br>  status = pthread_mutex_lock(_mutex);<br>  assert (status == 0, “invariant”) ;<br>  s = _counter;<br>  _counter = 1;<br>  if (s &lt; 1) {<br>     if (WorkAroundNPTLTimedWaitHang) {<br>        status = pthread_cond_signal (_cond) ;<br>        assert (status == 0, “invariant”) ;<br>        status = pthread_mutex_unlock(_mutex);<br>        assert (status == 0, “invariant”) ;<br>     } else {<br>        status = pthread_mutex_unlock(_mutex);<br>        assert (status == 0, “invariant”) ;<br>        status = pthread_cond_signal (_cond) ;<br>        assert (status == 0, “invariant”) ;<br>     }<br>  } else {<br>    pthread_mutex_unlock(_mutex);<br>    assert (status == 0, “invariant”) ;<br>  }<br>}</p>
<p>简而言之，是用mutex和condition保护了一个_counter的变量，当park时，这个变量置为了0，当unpark时，这个变量置为1。 <strong>值得注意的是在park函数里，调用pthread_cond_wait时，并没有用while来判断，所以posix condition里的”Spurious wakeup”一样会传递到上层Java的代码里。</strong></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/04/13/111/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/13/111/" class="post-title-link" itemprop="url">111</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-13 10:38:02" itemprop="dateCreated datePublished" datetime="2018-04-13T10:38:02+08:00">2018-04-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/knowledge/" itemprop="url" rel="index"><span itemprop="name">knowledge</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在分析java并发包java.util.concurrent源码的时候，少不了需要了解AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是java并发包的基础工具类，是实现ReentrantLock、CountDownLatch、Semaphore、FutureTask等类的基础。 Google一下AbstractQueuedSynchronizer，我们可以找到很多关于AQS的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。 本文将从ReentrantLock的公平锁源码出发，分析下AbstractQueuedSynchronizer这个类是怎么工作的，希望能给大家提供一些简单的帮助。 申明以下几点：</p>
<ol>
<li>本文有点长，但是很简单很简单很简单，主要面向读者对象为并发编程的初学者，或者想要阅读java并发包源码的开发者。</li>
<li>建议在电脑上阅读，如果你想好好地理解所有的细节，而且你从来没看过相关的分析，你可能至少需要20分钟仔细看所有的描述，本文后面的1/3以上很简单，前面的1/4更简单，中间的部分要好好看。</li>
<li>如果你不知道为什么要看这个，我想告诉你，即使你看懂了所有的细节，你可能也不能把你的业务代码写得更好</li>
<li>源码环境JDK1.7，看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea大神的代码写得真心不错。</li>
<li>有很多英文注释我没有删除，这样读者可以参考着英文说的来，万一被我忽悠了呢</li>
<li>本文不分析共享模式，这样可以给读者减少很多负担，只要把独占模式看懂，共享模式读者应该就可以顺着代码看懂了。而且也不分析condition部分，所以应该说很容易就可以看懂了。</li>
<li>本文大量使用我们平时用得最多的ReentrantLock的概念，本质上来说是不正确的，读者应该清楚，AQS不仅仅用来实现锁，只是希望读者可以用锁来联想AQS的使用场景，降低读者的阅读压力</li>
<li>ReentrantLock的公平锁和非公平锁只有一点点区别，没有任何阅读压力</li>
<li>你需要提前知道什么是CAS(CompareAndSet)</li>
</ol>
<p>废话结束，开始。</p>
<h2 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h2><p>先来看看AQS有哪些属性，搞清楚这些基本就知道AQS是什么套路了，毕竟可以猜嘛！</p>
<p>// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的<br>private transient volatile Node head;<br>// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个隐视的链表<br>private transient volatile Node tail;<br>// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁<br>// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1<br>private volatile int state;<br>// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入<br>// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁<br>// if (currentThread == getExclusiveOwnerThread()) {state++}<br>private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</p>
<p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。 AbstractQueuedSynchronizer的等待队列示意如下所示，注意了，之后分析过程中所说的queue，也就是阻塞队列不包含head，不包含head，不包含head。 <a href="http://7rf34y.com2.z0.glb.qiniucdn.com/c/d9d29ee005be7ff2720a9fd2615e1499" target="_blank" rel="noopener"><img src="https://mail.qq.com/cgi-bin/viewfile?f=687B756EADCF463FDEDCA1BE488141359C4D6710462C720516D49B9FDAD7FFCC404F171C31DBA4EB643551CC4A8071CBBEAAD9EEBEF8E3DD2D0E7213A61B702C1CF4CF5CC8BDDE816AA2A35A4C14226B1A6FDBB1355F8D0A9F9754E56AD9E3E2&amp;mailid=ZL0413-HmXfIml%7EBCz8dnErQtq3b84&amp;sid=tM8fg8jfj6d3fnkj&amp;net=806938378" alt></a> 等待队列中每个线程被包装成一个node，数据结构是链表，一起看看源码吧：</p>
<p>static final class Node {<br>    /** Marker to indicate a node is waiting in shared mode <em>/<br>    // 标识节点当前在共享模式下<br>    static final Node SHARED = new Node();<br>    /\</em>* Marker to indicate a node is waiting in exclusive mode */<br>    // 标识节点当前在独占模式下<br>    static final Node EXCLUSIVE = null;</p>
<pre><code>// ======== 下面的几个int常量是给waitStatus用的 ===========
/\*\* waitStatus value to indicate thread has cancelled */
// 代码此线程取消了争抢这个锁
static final int CANCELLED =  1;
/\*\* waitStatus value to indicate successor&apos;s thread needs unparking */
// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒
static final int SIGNAL    = -1;
/\*\* waitStatus value to indicate thread is waiting on condition */
// 本文不分析condition，所以略过吧
static final int CONDITION = -2;
/\*\*
 \* waitStatus value to indicate the next acquireShared should
 \* unconditionally propagate
 */
// 同样的不分析，略过吧
static final int PROPAGATE = -3;
// =====================================================

// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)
// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，
// 也许就是说半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。
volatile int waitStatus;
// 前驱节点的引用
volatile Node prev;
// 后继节点的引用
volatile Node next;
// 这个就是线程本尊
volatile Thread thread;
</code></pre><p>}</p>
<p>Node的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。 上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说ReentrantLock的公平锁。多嘴一下，我说的阻塞队列不包含head节点。 <a href="http://7rf34y.com2.z0.glb.qiniucdn.com/c/d9d29ee005be7ff2720a9fd2615e1499" target="_blank" rel="noopener"><img src="https://mail.qq.com/cgi-bin/viewfile?f=687B756EADCF463FDEDCA1BE488141359C4D6710462C720516D49B9FDAD7FFCC404F171C31DBA4EB643551CC4A8071CBBEAAD9EEBEF8E3DD4AF737FBADD0A432DB0AD391858615312A38B68E3DA80438F9ECA8B1C7F7F4586E51073A2C6013F3&amp;mailid=ZL0413-HmXfIml%7EBCz8dnErQtq3b84&amp;sid=tM8fg8jfj6d3fnkj&amp;net=806938378" alt></a> 首先，我们先看下ReentrantLock的使用方式。</p>
<p>// 我用个web开发中的service概念吧<br>public class OrderService {<br>    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个<br>    private static ReentrantLock reentrantLock = new ReentrantLock(true);</p>
<pre><code>public void createOrder() {
    try {
        // 比如我们同一时间，只允许一个线程创建订单
        reentrantLock.lock();

        // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，
        // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来
        // 执行代码...
        // 执行代码...
        // 执行代码...
    } finally {
        // 释放锁
        reentrantLock.unlock();
    }
}
</code></pre><p>}</p>
<p>ReentrantLock在内部用了内部类Sync来管理锁，所以真正的获取锁和释放锁是由Sync的实现类来控制的。</p>
<p>abstract static class Sync extends AbstractQueuedSynchronizer {</p>
<p>}</p>
<p>Sync有两个实现，分别为NonfairSync（非公平锁）和FairSync（公平锁），我们看FairSync部分。</p>
<p>public ReentrantLock(boolean fair) {<br>    sync = fair ? new FairSync() : new NonfairSync();<br>}</p>
<h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p>
<p>static final class FairSync extends Sync {<br>    private static final long serialVersionUID = -3000897897090466540L;<br>      // 争锁<br>    final void lock() {<br>        acquire(1);<br>    }<br>      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力<br>    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。<br>    // 否则，acquireQueued方法会将线程压到队列中<br>    public final void acquire(int arg) { // 此时 arg == 1<br>        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试<br>        // 因为有可能直接就成功了呢，也就不需要进队列排队了，<br>        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)<br>        if (!tryAcquire(arg) &amp;&amp;<br>            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {<br>              selfInterrupt();<br>        }<br>    }<br>    /**<br>     * Fair version of tryAcquire.  Don’t grant access unless<br>     * recursive call or no waiters or is first.<br>     */<br>    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁<br>    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取<br>    protected final boolean tryAcquire(int acquires) {<br>        final Thread current = Thread.currentThread();<br>        int c = getState();<br>        // state == 0 此时此刻没有线程持有锁<br>        if (c == 0) {<br>            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，<br>            // 看看有没有别人在队列中等了半天了<br>            if (!hasQueuedPredecessors() &amp;&amp;<br>                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，<br>                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=<br>                // 因为刚刚还没人的，我判断过了<br>                compareAndSetState(0, acquires)) {</p>
<pre><code>            // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁
            setExclusiveOwnerThread(current);
            return true;
        }
    }
      // 会进入这个else if分支，说明是重入了，需要操作：state=state+1
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁
    // 回到上面一个外层调用方法继续看:
    // if (!tryAcquire(arg) 
    //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
    //     selfInterrupt();
    return false;
}

// 假设tryAcquire(arg) 返回false，那么代码将执行：
  //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，
// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)

/\*\*
 \* Creates and enqueues node for current thread and given mode.
 \*
 \* @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
 \* @return the new node
 */
// 此方法的作用是把线程包装成node，同时进入到队列中
// 参数mode此时是Node.EXCLUSIVE，代表独占模式
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后
    Node pred = tail;

    // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)
    if (pred != null) { 
        // 设置自己的前驱 为当前的队尾节点
        node.prev = pred; 
        // 用CAS把自己设置为队尾, 如果成功后，tail == node了
        if (compareAndSetTail(pred, node)) { 
            // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，
            // 上面已经有 node.prev = pred
            // 加上下面这句，也就实现了和之前的尾节点双向连接了
            pred.next = node;
            // 线程入队了，可以返回了
            return node;
        }
    }
    // 仔细看看上面的代码，如果会到这里，
    // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)
    // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的
    enq(node);
    return node;
}

/\*\*
 \* Inserts node into queue, initializing if necessary. See picture above.
 \* @param node the node to insert
 \* @return node&apos;s predecessor
 */
// 采用自旋的方式入队
// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，
// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        // 之前说过，队列为空也会进来这里
        if (t == null) { // Must initialize
            // 初始化head节点
            // 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心
            // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢
            if (compareAndSetHead(new Node()))
                // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了

                // 这个时候有了head，但是tail还是null，设置一下，
                // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了
                // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return
                // 所以，设置完了以后，继续for循环，下次就到下面的else分支了
                tail = head;
        } else {
            // 下面几行，和上一个方法 addWaiter 是一样的，
            // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}


// 现在，又回到这段代码了
// if (!tryAcquire(arg) 
//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
//     selfInterrupt();

// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列
// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，
// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false
// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head
            // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列
            // 所以当前节点可以去试抢一下锁
            // 这里我们说一下，为什么可以去试试：
            // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，
            // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程
            // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，
            // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，
            // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

/\*\*
 \* Checks and updates status for a node that failed to acquire.
 \* Returns true if thread should block. This is the main signal
 \* control in all acquire loops.  Requires that pred == node.prev
 \*
 \* @param pred node&apos;s predecessor holding status
 \* @param node the node
 \* @return {@code true} if thread should block
 */
// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;
// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true
    if (ws == Node.SIGNAL)
        /\*
         \* This node has already set status asking a release
         \* to signal it, so it can safely park.
         */
        return true;

    // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：
    // 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。
    // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，
    // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，
    // 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的
    if (ws &gt; 0) {
        /\*
         \* Predecessor was cancelled. Skip over predecessors and
         \* indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        /\*
         \* waitStatus must be 0 or PROPAGATE.  Indicate that we
         \* need a signal, but don&apos;t park yet.  Caller will need to
         \* retry to make sure it cannot acquire before parking.
         */
        // 仔细想想，如果进入到这个分支意味着什么
        // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3
        // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0
        // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}

// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)
// 这个方法结束根据返回值我们简单分析下：
// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒
//        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了
// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看

// 跳回到前面是这个方法
// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
//                parkAndCheckInterrupt())
//                interrupted = true;

// 1\. 如果shouldParkAfterFailedAcquire(p, node)返回true，
// 那么需要执行parkAndCheckInterrupt():

// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的
// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}

// 2\. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况
</code></pre><p>   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</p>
<pre><code>// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：
// =\&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。
</code></pre><p>}</p>
<p>说到这里，也就明白了，多看几遍final boolean acquireQueued(final Node node, int arg)这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p>
<h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被LockSupport.park(this);挂起停止，等待被唤醒。</p>
<p>// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了<br>public final boolean release(int arg) {<br>    // 往后看吧<br>    if (tryRelease(arg)) {<br>        Node h = head;<br>        if (h != null &amp;&amp; h.waitStatus != 0)<br>            unparkSuccessor(h);<br>        return true;<br>    }<br>    return false;<br>}<br>// 回到ReentrantLock看tryRelease方法<br>protected final boolean tryRelease(int releases) {<br>    int c = getState() - releases;<br>    if (Thread.currentThread() != getExclusiveOwnerThread())<br>        throw new IllegalMonitorStateException();<br>    // 是否完全释放锁<br>    boolean free = false;<br>    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉<br>    if (c == 0) {<br>        free = true;<br>        setExclusiveOwnerThread(null);<br>    }<br>    setState(c);<br>    return free;<br>}<br>/**<br> * Wakes up node’s successor, if one exists.<br> *<br> * @param node the node<br> <em>/<br>// 唤醒后继节点<br>// 从上面调用处知道，参数node是head头结点<br>private void unparkSuccessor(Node node) {<br>    /\</em><br>     * If status is negative (i.e., possibly needing signal) try<br>     * to clear in anticipation of signalling.  It is OK if this<br>     * fails or if status is changed by waiting thread.<br>     <em>/<br>    int ws = node.waitStatus;<br>    // 如果head节点当前waitStatus&lt;0, 将其修改为0<br>    if (ws &lt; 0)<br>        compareAndSetWaitStatus(node, ws, 0);<br>    /\</em><br>     * Thread to unpark is held in successor, which is normally<br>     * just the next node.  But if cancelled or apparently null,<br>     * traverse backwards from tail to find the actual<br>     * non-cancelled successor.<br>     */<br>    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）<br>    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的<br>    Node s = node.next;<br>    if (s == null || s.waitStatus &gt; 0) {<br>        s = null;<br>        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况<br>        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)<br>            if (t.waitStatus &lt;= 0)<br>                s = t;<br>    }<br>    if (s != null)<br>        // 唤醒线程<br>        LockSupport.unpark(s.thread);<br>}</p>
<p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p>
<p>private final boolean parkAndCheckInterrupt() {<br>    LockSupport.park(this); // 刚刚线程被挂起在这里了<br>    return Thread.interrupted();<br>}<br>// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</p>
<p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。 在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是state的作用，它为0的时候代表没有线程占有锁，可以去争抢这个锁，用CAS将state设为1，如果CAS成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行+1就可以，解锁就是减1，直到state又变为0，代表释放锁，所以lock()和unlock()必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS中采用了LockSupport.park(thread) 来挂起线程，用unpark来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个queue来管理这些线程，AQS用的是一个FIFO的队列，就是一个链表，每个node都持有后继节点的引用。AQS采用了CLH锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了: <a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">http://coderbee.net/index.php/concurrent/20131115/577</a></li>
</ol>
<h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。 首先，第一个线程调用reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回true了，结束。只是设置了state=1，连head都没有初始化，更谈不上什么阻塞队列了。要是线程1调用unlock()了，才有线程2来，那世界就太太太平了，完全没有交集嘛，那我还要AQS干嘛。 如果线程1没有调用unlock()之前，线程2调用了lock(), 想想会发生什么？ 线程2会初始化head【new Node()】，同时线程2也会插入到阻塞队列并挂起 (注意看这里是一个for循环，而且设置head和tail的部分是不return的，只有入队成功才会跳出循环)</p>
<p>private Node enq(final Node node) {<br>    for (;;) {<br>        Node t = tail;<br>        if (t == null) { // Must initialize<br>            if (compareAndSetHead(new Node()))<br>                tail = head;<br>        } else {<br>            node.prev = t;<br>            if (compareAndSetTail(t, node)) {<br>                t.next = node;<br>                return t;<br>            }<br>        }<br>    }<br>}</p>
<p>首先，是线程2初始化head节点，此时head==tail, waitStatus==0 <a href="http://7rf34y.com2.z0.glb.qiniucdn.com/c/f9db7234dfc8b15ad6717ab6c05fd0dd" target="_blank" rel="noopener"><img src="https://mail.qq.com/cgi-bin/viewfile?f=687B756EADCF463FDEDCA1BE488141359C4D6710462C720516D49B9FDAD7FFCC404F171C31DBA4EB643551CC4A8071CBBEAAD9EEBEF8E3DD4AF737FBADD0A432DB0AD391858615312A38B68E3DA80438F9ECA8B1C7F7F4586E51073A2C6013F3&amp;mailid=ZL0413-HmXfIml%7EBCz8dnErQtq3b84&amp;sid=tM8fg8jfj6d3fnkj&amp;net=806938378" alt></a> 然后线程2入队： <a href="http://7rf34y.com2.z0.glb.qiniucdn.com/c/fb1a9354c5ca6045cf9039de4d68d38f" target="_blank" rel="noopener"><img src="https://mail.qq.com/cgi-bin/viewfile?f=687B756EADCF463FDEDCA1BE488141359C4D6710462C720516D49B9FDAD7FFCC404F171C31DBA4EB643551CC4A8071CBBEAAD9EEBEF8E3DD4AF737FBADD0A432DB0AD391858615312A38B68E3DA80438F9ECA8B1C7F7F4586E51073A2C6013F3&amp;mailid=ZL0413-HmXfIml%7EBCz8dnErQtq3b84&amp;sid=tM8fg8jfj6d3fnkj&amp;net=806938378" alt></a> 同时我们也要看此时节点的waitStatus，我们知道head节点是线程2初始化的，此时的waitStatus没有设置，java默认会设置为0，但是到shouldParkAfterFailedAcquire这个方法的时候，线程2会把前驱节点，也就是head的waitStatus设置为-1。 那线程2节点此时的waitStatus是多少呢，由于没有设置，所以是0； 如果线程3此时再进来，直接插到线程2的后面就可以了，此时线程3的waitStatus是0，到shouldParkAfterFailedAcquire方法的时候把前驱节点线程2的waitStatus设置为-1。 <a href="http://7rf34y.com2.z0.glb.qiniucdn.com/c/f2c281760b94e7126dc3f328c0d8da65" target="_blank" rel="noopener"><img src="https://mail.qq.com/cgi-bin/viewfile?f=687B756EADCF463FDEDCA1BE488141359C4D6710462C720516D49B9FDAD7FFCC404F171C31DBA4EB643551CC4A8071CBBEAAD9EEBEF8E3DD4AF737FBADD0A432DB0AD391858615312A38B68E3DA80438F9ECA8B1C7F7F4586E51073A2C6013F3&amp;mailid=ZL0413-HmXfIml%7EBCz8dnErQtq3b84&amp;sid=tM8fg8jfj6d3fnkj&amp;net=806938378" alt></a> 这里可以简单说下waitStatus中SIGNAL(-1)状态的意思，Doug Lea注释的是：代表后继节点需要被唤醒。也就是说这个waitStatus其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个node在入队的时候，都会把前驱节点的状态改为SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着“waitStatus代表后继节点的状态”这种思路去看一遍源码。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/03/28/minor-gc-e3-80-81major-gc-e5-92-8cfull-gc-e4-b9-8b-e9-97-b4-e7-9a-84-e5-8c-ba-e5-88-ab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/minor-gc-e3-80-81major-gc-e5-92-8cfull-gc-e4-b9-8b-e9-97-b4-e7-9a-84-e5-8c-ba-e5-88-ab/" class="post-title-link" itemprop="url">Minor GC、Major GC和Full GC之间的区别</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-28 14:23:09" itemprop="dateCreated datePublished" datetime="2018-03-28T14:23:09+08:00">2018-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  文章要求读者熟悉 JVM 内置的通用垃圾回收原则。堆内存划分为 Eden、Survivor 和 Tenured/Old 空间，代假设和其他不同的 GC 算法超出了本文讨论的范围。 <a href="http://jbcdn2.b0.upaiyun.com/2015/03/fd0c0db33776f042f62e5386131e487c.jpg" title="Minor GC、Major GC和Full GC之间的区别" target="_blank" rel="noopener"><img src="http://jbcdn2.b0.upaiyun.com/2015/03/fd0c0db33776f042f62e5386131e487c.jpg" alt="minor-gc-major-gc-full-gc"></a></p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：</p>
<ol>
<li>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。</li>
<li>内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。</li>
<li>执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。</li>
<li><strong>质疑常规的认知，所有的 Minor GC 都会</strong>触发<strong>“全世界的暂停（stop-the-world）”</strong>，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。</li>
</ol>
<p>所以 Minor GC 的情况就相当清楚了——<strong>每次 Minor GC 会清理年轻代的内存</strong>。</p>
<h3 id="Major-GC-vs-Full-GC"><a href="#Major-GC-vs-Full-GC" class="headerlink" title="Major GC vs Full GC"></a>Major GC vs Full GC</h3><p>大家应该注意到，目前，这些术语无论是在 JVM 规范还是在垃圾收集研究论文中都没有正式的定义。但是我们一看就知道这些在我们已经知道的基础之上做出的定义是正确的，Minor GC 清理年轻带内存应该被设计得简单：</p>
<ul>
<li><strong>Major GC</strong> 是清理老年代。</li>
<li><strong>Full GC</strong> 是清理整个堆空间—包括年轻代和老年代。</li>
</ul>
<p>很不幸，实际上它还有点复杂且令人困惑。首先，许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。另一方面，许多现代垃圾收集机制会清理部分永久代空间，所以使用“cleaning”一词只是部分正确。 这使得我们不用去关心<strong>到底是叫 Major GC 还是 Full GC，大家应该关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程</strong>。 这种混乱甚至内置到 JVM 标准工具。下面一个例子很好的解释了我的意思。让我们比较两个不同的工具 Concurrent Mark 和 Sweep collector (<em>-XX:+UseConcMarkSweepGC</em>)在 JVM 中运行时输出的跟踪记录。 第一次尝试通过 <em><a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">jstat</a></em> 输出：my-precious: me$ jstat -gc -t 4235 1s</p>
<p>Time S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br> 5.7 34048.0 34048.0  0.0   34048.0 272640.0 194699.7 1756416.0   181419.9  18304.0 17865.1 2688.0 2497.6      3    0.275   0      0.000    0.275<br> 6.7 34048.0 34048.0 34048.0  0.0   272640.0 247555.4 1756416.0   263447.9  18816.0 18123.3 2688.0 2523.1      4    0.359   0      0.000    0.359<br> 7.7 34048.0 34048.0  0.0   34048.0 272640.0 257729.3 1756416.0   345109.8  19072.0 18396.6 2688.0 2550.3      5    0.451   0      0.000    0.451<br> 8.7 34048.0 34048.0 34048.0 34048.0 272640.0 272640.0 1756416.0  444982.5  19456.0 18681.3 2816.0 2575.8      7    0.550   0      0.000    0.550<br> 9.7 34048.0 34048.0 34046.7  0.0   272640.0 16777.0  1756416.0   587906.3  20096.0 19235.1 2944.0 2631.8      8    0.720   0      0.000    0.720<br>10.7 34048.0 34048.0  0.0   34046.2 272640.0 80171.6  1756416.0   664913.4  20352.0 19495.9 2944.0 2657.4      9    0.810   0      0.000    0.810<br>11.7 34048.0 34048.0 34048.0  0.0   272640.0 129480.8 1756416.0   745100.2  20608.0 19704.5 2944.0 2678.4     10    0.896   0      0.000    0.896<br>12.7 34048.0 34048.0  0.0   34046.6 272640.0 164070.7 1756416.0   822073.7  20992.0 19937.1 3072.0 2702.8     11    0.978   0      0.000    0.978<br>13.7 34048.0 34048.0 34048.0  0.0   272640.0 211949.9 1756416.0   897364.4  21248.0 20179.6 3072.0 2728.1     12    1.087   1      0.004    1.091<br>14.7 34048.0 34048.0  0.0   34047.1 272640.0 245801.5 1756416.0   597362.6  21504.0 20390.6 3072.0 2750.3     13    1.183   2      0.050    1.233<br>15.7 34048.0 34048.0  0.0   34048.0 272640.0 21474.1  1756416.0   757347.0  22012.0 20792.0 3200.0 2791.0     15    1.336   2      0.050    1.386<br>16.7 34048.0 34048.0 34047.0  0.0   272640.0 48378.0  1756416.0   838594.4  22268.0 21003.5 3200.0 2813.2     16    1.433   2      0.050    1.484</p>
<p>这个片段是 JVM 启动后第17秒提取的。基于该信息，我们可以得出这样的结果，运行了12次 Minor GC、2次 Full GC，时间总跨度为<strong>50毫秒</strong>。通过 <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html" target="_blank" rel="noopener">jconsole</a> 或者 <a href="http://download.oracle.com/javase/6/docs/technotes/tools/share/jvisualvm.html" target="_blank" rel="noopener">jvisualvm</a> 这样的基于GUI的工具你能得到同样的结果。</p>
<p>java -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC eu.plumbr.demo.GarbageProducer</p>
<p>3.157: [GC (Allocation Failure) 3.157: [ParNew: 272640K-&gt;34048K(306688K), 0.0844702 secs] 272640K-&gt;69574K(2063104K), 0.0845560 secs] [Times: user=0.23 sys=0.03, real=0.09 secs]<br>4.092: [GC (Allocation Failure) 4.092: [ParNew: 306688K-&gt;34048K(306688K), 0.1013723 secs] 342214K-&gt;136584K(2063104K), 0.1014307 secs] [Times: user=0.25 sys=0.05, real=0.10 secs]<br>… cut for brevity …<br>11.292: [GC (Allocation Failure) 11.292: [ParNew: 306686K-&gt;34048K(306688K), 0.0857219 secs] 971599K-&gt;779148K(2063104K), 0.0857875 secs] [Times: user=0.26 sys=0.04, real=0.09 secs]<br>12.140: [GC (Allocation Failure) 12.140: [ParNew: 306688K-&gt;34046K(306688K), 0.0821774 secs] 1051788K-&gt;856120K(2063104K), 0.0822400 secs] [Times: user=0.25 sys=0.03, real=0.08 secs]<br>12.989: [GC (Allocation Failure) 12.989: [ParNew: 306686K-&gt;34048K(306688K), 0.1086667 secs] 1128760K-&gt;931412K(2063104K), 0.1087416 secs] [Times: user=0.24 sys=0.04, real=0.11 secs]<br>13.098: [GC (CMS Initial Mark) [1 CMS-initial-mark: 897364K(1756416K)] 936667K(2063104K), 0.0041705 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]<br>13.102: [CMS-concurrent-mark-start]<br>13.341: [CMS-concurrent-mark: 0.238/0.238 secs] [Times: user=0.36 sys=0.01, real=0.24 secs]<br>13.341: [CMS-concurrent-preclean-start]<br>13.350: [CMS-concurrent-preclean: 0.009/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]<br>13.350: [CMS-concurrent-abortable-preclean-start]<br>13.878: [GC (Allocation Failure) 13.878: [ParNew: 306688K-&gt;34047K(306688K), 0.0960456 secs] 1204052K-&gt;1010638K(2063104K), 0.0961542 secs] [Times: user=0.29 sys=0.04, real=0.09 secs]<br>14.366: [CMS-concurrent-abortable-preclean: 0.917/1.016 secs] [Times: user=2.22 sys=0.07, real=1.01 secs]<br>14.366: [GC (CMS Final Remark) [YG occupancy: 182593 K (306688 K)]14.366: [Rescan (parallel) , 0.0291598 secs]14.395: [weak refs processing, 0.0000232 secs]14.395: [class unloading, 0.0117661 secs]14.407: [scrub symbol table, 0.0015323 secs]14.409: [scrub string table, 0.0003221 secs][1 CMS-remark: 976591K(1756416K)] 1159184K(2063104K), 0.0462010 secs] [Times: user=0.14 sys=0.00, real=0.05 secs]<br>14.412: [CMS-concurrent-sweep-start]<br>14.633: [CMS-concurrent-sweep: 0.221/0.221 secs] [Times: user=0.37 sys=0.00, real=0.22 secs]<br>14.633: [CMS-concurrent-reset-start]</p>
<p>在点头同意这个结论之前，让我们看看来自同一个 JVM 启动收集的垃圾收集日志的输出。显然- XX ： + PrintGCDetails 告诉我们一个不同且更详细的故事：</p>
<p>基于这些信息，我们可以看到12次 Minor GC 后开始有些和上面不一样了。没有运行两次 Full GC，这不同的地方在于单个 GC 在永久代中不同阶段运行了两次：</p>
<ul>
<li>最初的标记阶段，用了0.0041705秒也就是4ms左右。这个阶段会暂停“全世界（ stop-the-world）”的事件，停止所有应用程序的线程，然后开始标记。</li>
<li>并行执行标记和清洗阶段。这些都是和应用程序线程并行的。</li>
<li>最后 Remark 阶段，花费了0.0462010秒约46ms。这个阶段会再次暂停所有的事件。</li>
<li>并行执行清理操作。正如其名，此阶段也是并行的，不会停止其他线程。</li>
</ul>
<p>所以，正如我们从垃圾回收日志中所看到的那样，实际上只是执行了 Major GC 去清理老年代空间而已，而不是执行了两次 Full GC。 如果你是后期做决 定的话，那么由 jstat 提供的数据会引导你做出正确的决策。它正确列出的两个暂停所有事件的情况，导致所有线程停止了共计50ms。但是如果你试图优化吞吐量，你会被误导的。清 单只列出了回收初始标记和最终 Remark 阶段，jstat的输出看不到那些并发完成的工作。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>考虑到这种情况，最好避免以 Minor、Major、Full GC 这种方式来思考问题。而应该监控应用延迟或者吞吐量，然后将 GC 事件和结果联系起来。 随着这些 GC 事件的发生，你需要额外的关注某些信息，GC 事件是强制所有应用程序线程停止了还是并行的处理了部分事件。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/03/28/jvm-e5-b7-a5-e5-85-b7-jvisualvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/jvm-e5-b7-a5-e5-85-b7-jvisualvm/" class="post-title-link" itemprop="url">JVM工具 jvisualvm</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-28 09:40:50" itemprop="dateCreated datePublished" datetime="2018-03-28T09:40:50+08:00">2018-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后端开发/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jvisualvm能干什么：监控内存泄露，跟踪垃圾回收，执行时内存、cpu分析，线程分析…   jvisualvm已经被集成在jdk1.6以上的版本中(不是jre)。自身运行需要最低jdk1.6版本，但是可以监控运行在jdk1.4以上版本的java程序 以jdk1.6update45(jdk1.6update45自带的jvisualvm)来做说明，当然也可单独下载独立的jvisualvm，正常安装完jdk后，至jdk的bin目录下，运行jvisualvm.exe即可 <img src="http://img.my.csdn.net/uploads/201212/25/1356421514_6174.png" alt> 网上有人说jvisualvm对ntfs的硬盘格式支持的不好（都说不好，也没说到底哪里不好），反正我用着是挺正常的，不管怎么样先把解决方式记下来吧 创建jvisualvm.exe的快捷方式，右键快捷方式选择属性，在“目标”栏中追加”-XX:+PerfBypassFileSystemCheck” <img src="http://img.my.csdn.net/uploads/201212/25/1356421974_8908.jpg" alt> 程序运行后会自动监控本机运行的java程序（Local标签下，远程服务器上的java程序需要另行配置），如果是下载的jvisualvm，解压后，运行bin目录下的jvisualvm.exe即可 Local标签下的第一个VisualVM为jvisualvm对自身的监控，可以看到消耗的资源还是很少的，第二个为本机的eclipse <img src="http://img.my.csdn.net/uploads/201212/28/1356658216_1476.png" alt> 监控项总共分为Overview，Monitor，Threads和一个Sampler。 <strong>1.Overview（jvm启动参数，系统参数）</strong> <img src="http://img.my.csdn.net/uploads/201212/28/1356658532_9561.png" alt> 可以看到eclipse的启动参数 <img src="http://img.my.csdn.net/uploads/201212/25/1356424196_8620.png" alt> (通过这些启动参数，可以判断程序是否有内存溢出) <strong>2.Monitor</strong> <img src="http://img.my.csdn.net/uploads/201212/28/1356658833_4248.png" alt> 左上：cpu利用率，gc状态的监控 右上：堆利用率，永久内存区的利用率 左下：类的监控 右下：线程的监控 performGC：gc的详细运行状态 HeapDump：堆的详细状态（可以看到堆的概况，里面所有的类，还能点进具体的一个类查看这个类的状态） <strong>3.Threads</strong> <img src="http://img.my.csdn.net/uploads/201212/28/1356659239_3404.png" alt> 能够显示线程的名称和运行的状态，在调试多线程时必不可少，而且可以点进一个线程查看这个线程的详细运行情况 <strong>监控服务器上的tomcat</strong> tomcat的配置文件catalina.sh中增加:</p>
<ol>
<li>JAVA_OPTS=”-Dcom.sun.management.jmxremote.port=9998</li>
<li>-Dcom.sun.management.jmxremote.ssl=false</li>
<li>-Dcom.sun.management.jmxremote.authenticate=false</li>
<li>-Djava.rmi.server.hostname=192.168.58.164”</li>
</ol>
<p>参数说明:</p>
<ol>
<li>指定了JMX启动的代理端口，这个端口就是visualvm要连接的端口（9998端口不能被别的程序使用netstat -an|gerp 9998）</li>
<li>Dcom.sun.management.jmxremote.port=9998</li>
<li>指定了JMX是否启用ssl</li>
<li>Dcom.sun.management.jmxremote.authenticate=false</li>
<li>指定了JMX是否启用鉴权（需要用户名，密码鉴权）</li>
<li>Dcom.sun.management.jmxremote.authenticate=false</li>
<li>指定了服务器主机名</li>
<li>Djava.rmi.server.hostname=192.168.58.164</li>
</ol>
<p><img src="http://img.my.csdn.net/uploads/201212/28/1356659492_3452.png" alt> 填写主机名： <img src="http://img.blog.csdn.net/20130918170902453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 右键创建一个jmx连接： <img src="http://img.my.csdn.net/uploads/201212/28/1356660131_3194.png" alt> 填写上端口号即可：</p>
<p><img src="http://img.my.csdn.net/uploads/201212/25/1356426256_4304.jpg" alt></p>
<p>配置完成：</p>
<p><img src="http://img.my.csdn.net/uploads/201212/28/1356660551_8853.png" alt>   <strong>监控服务器上的java程序</strong> 相较于监控tomcat要麻烦很多，要预先启动jstatd服务（${java_home}/bin目录下） jstatd是一个监控JVM从创建到销毁过程中资源占用情况并提供远程监控接口的RMI（Remote Method Invocation，远程方法调用）服务器程序，它是一个Daemon程序（后台进程），要保证远程监控软件连接到本地的话需要jstatd始终保持运行。 jstatd运行需要通过-J-Djava.security.policy=***指定安全策略，因此我们需要在服务器上建立一个指定安全策略的文件jstatd.all.policy（我放在了${java_home}/bin目录下），文件内容如下：</p>
<ol>
<li>grant codebase “file:/home/123/123/jdk1.5.0_15/lib/tools.jar” {</li>
<li>permission java.security.AllPermission;</li>
<li>};</li>
</ol>
<p>然后使用这个策略文件启动jstatd服务</p>
<ol>
<li>[123@123 bin]$ pwd</li>
<li>/home/123/123/jdk1.5.0_15/bin</li>
<li>[123@123 bin]$ ./jstatd -J-Djava.security.policy=./jstatd.all.policy &amp;</li>
</ol>
<p>因为监控的过程中需要jstatd服务一直运行，所以加上了&amp;，如果需要日志也可使用:</p>
<ol>
<li>./jstatd -J-Djava.security.policy=./jstatd.all.policy -J-Djava.rmi.server.logCalls=true</li>
</ol>
<p>接下来就可以在jvisualvm中配置监控该服务器上运行的java程序了，和在jvisualvm中配置监控tomcat服务器的操作过程是一样的 需要特别注意的是，有时在配置远程监控java程序的时候jvisualvm会报一个错误 点击查看错误详情： <img src="http://img.my.csdn.net/uploads/201212/26/1356513076_2032.png" alt> connection refused to host:127.0.0.1初步判断和主机名有关系</p>
<ol>
<li>[123@123 bin]# hostname -i</li>
<li><p>127.0.0.1</p>
</li>
<li><p>[123@123 bin]# hostname 192.168.58.168</p>
</li>
</ol>
<p>修改完重启jstatd服务（网上很多人说要修改主机的/etc/hosts文件，但是我自己测试修改/etc/hosts文件是没有效果的，必须要修改主机名）</p>
<p><img src="http://img.my.csdn.net/uploads/201212/28/1356659492_3452.png" alt></p>
<p>填写主机名： <img src="http://img.blog.csdn.net/20130918170902453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 这里要选添加一个jstatd连接： <img src="http://img.my.csdn.net/uploads/201212/28/1356660131_3194.png" alt> 直接选择默认配置即可（默认使用1099端口）： <img src="http://img.my.csdn.net/uploads/201212/28/1356661065_3854.png" alt> 点击ok后，168上的所有java程序就会自动列出： <img src="http://img.my.csdn.net/uploads/201212/28/1356661122_1872.png" alt> PS: jvisualvm也是可以安装插件的，具体步骤为tool -&gt; plugin -&gt;aviable plugin，推荐一个非常好用的插件VisualGC <img src="http://img.blog.csdn.net/20131025173516906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 安装完这个插件后，将会增加新的监控条目Visual GC，可以看到虚拟机内存各个区的使用情况 <img src="http://img.blog.csdn.net/20131026232124656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/03/15/java-e5-b9-b6-e5-8f-91-e7-bc-96-e7-a8-8b-e5-8e-9f-e5-ad-90-e6-80-a7-ef-bc-8c-e6-9c-89-e5-ba-8f-e6-80-a7-ef-bc-8c-e5-8f-af-e8-a7-81-e6-80-a7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/15/java-e5-b9-b6-e5-8f-91-e7-bc-96-e7-a8-8b-e5-8e-9f-e5-ad-90-e6-80-a7-ef-bc-8c-e6-9c-89-e5-ba-8f-e6-80-a7-ef-bc-8c-e5-8f-af-e8-a7-81-e6-80-a7/" class="post-title-link" itemprop="url">Java并发编程-原子性，有序性，可见性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-15 17:48:54" itemprop="dateCreated datePublished" datetime="2018-03-15T17:48:54+08:00">2018-03-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习并发编程之前,我们要先了解并发编程的三大概念：原子性，有序性，可见性。</p>
<h3 id="一、原子性"><a href="#一、原子性" class="headerlink" title="一、原子性"></a>一、原子性</h3><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<h5 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h5><p>一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个64位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<p>i = 9;</p>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低32位赋值，为高32位赋值,那么就可能发生一种情况：当将低32位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h5 id="3-Java中的原子性"><a href="#3-Java中的原子性" class="headerlink" title="3.Java中的原子性"></a>3.Java中的原子性</h5><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作：</p>
<p>x = 10;         //语句1<br>y = x;         //语句2<br>x++;           //语句3<br>x = x + 1;     //语句4</p>
<p>咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 关于synchronized和Lock的使用，参考：<a href="http://www.jianshu.com/p/96c89e6e7e90" target="_blank" rel="noopener">关于synchronized和ReentrantLock之多线程同步详解</a></p>
<h3 id="二、可见性"><a href="#二、可见性" class="headerlink" title="二、可见性"></a>二、可见性</h3><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<h5 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="2.实例"></a>2.实例</h5><p>举个简单的例子，看下面这段代码：</p>
<p>//线程1执行的代码<br>int i = 0;<br>i = 10;</p>
<p>//线程2执行的代码<br>j = i;</p>
<p>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h5 id="3-Java中的可见性"><a href="#3-Java中的可见性" class="headerlink" title="3.Java中的可见性"></a>3.Java中的可见性</h5><p>对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h3 id="三、有序性"><a href="#三、有序性" class="headerlink" title="三、有序性"></a>三、有序性</h3><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<h5 id="2-实例-2"><a href="#2-实例-2" class="headerlink" title="2.实例"></a>2.实例</h5><p>举个简单的例子，看下面这段代码：</p>
<p>int i = 0;              </p>
<p>boolean flag = false;</p>
<p>i = 1;                //语句1<br>flag = true;          //语句2</p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<p>int a = 10;    //语句1<br>int r = 2;    //语句2<br>a = a + 3;    //语句3<br>r = a*a;     //语句4</p>
<p>这段代码有4个语句，那么可能的一个执行顺序是： 语句2 语句1 语句4 语句3 那么可不可能是这个执行顺序呢? 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<p>//线程1:</p>
<p>context = loadContext();   //语句1<br>inited = true;             //语句2</p>
<p> //线程2:<br>while(!inited ){<br>   sleep()<br>}<br>doSomethingwithconfig(context);</p>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h5 id="3-Java中的有序性"><a href="#3-Java中的有序性" class="headerlink" title="3.Java中的有序性"></a>3.Java中的有序性</h5><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<h5 id="下面就来具体介绍下happens-before原则（先行发生原则）："><a href="#下面就来具体介绍下happens-before原则（先行发生原则）：" class="headerlink" title="下面就来具体介绍下happens-before原则（先行发生原则）："></a>下面就来具体介绍下happens-before原则（先行发生原则）：</h5><p>①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 ②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作 ③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 ④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C ⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 ⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 ⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 ⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://b.zhongmin.me/2018/03/13/cas-e6-8c-87-e4-bb-a4-e4-b8-8emesi-e7-bc-93-e5-ad-98-e4-b8-80-e8-87-b4-e6-80-a7-e5-8d-8f-e8-ae-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaohe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/13/cas-e6-8c-87-e4-bb-a4-e4-b8-8emesi-e7-bc-93-e5-ad-98-e4-b8-80-e8-87-b4-e6-80-a7-e5-8d-8f-e8-ae-ae/" class="post-title-link" itemprop="url">CAS指令与MESI缓存一致性协议</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-13 19:41:19" itemprop="dateCreated datePublished" datetime="2018-03-13T19:41:19+08:00">2018-03-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-06 14:56:52" itemprop="dateModified" datetime="2019-05-06T14:56:52+08:00">2019-05-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/并发编程/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-CAS操作"><a href="#1-CAS操作" class="headerlink" title="1.CAS操作"></a><strong>1.CAS操作</strong></h3><p>CAS（Compare-And-Swap）指令是并行程序设计最基础的基石，随着越来越多的本本都用上了双核，这个世界已经快速步入并行计算时代，CAS指令发挥的作用也就越来越大。CAS指令，在Intel CPU上称为CMPXCHG，的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为所给的另一个值，这一系列操作是原子的，不可能被中断。基本上所有的同步机制，与信号量、Java中的synchronized等的实现最终都要用到CAS指令，即使锁无关的数据结构也离不开CAS指令。 关于CAS指令最著名的传闻是CAS需要锁总线，因此CAS指令不但慢而且会严重影响系统并发度，即使没有冲突是也一样。不过在较新的CPU中（对于Intel CPU来说是486之后），事实并非如此。目前的CPU一般都采用了很好的缓存一致性协议，在很多情况下能够防止锁总线的发生，这其中最著名的就是Intel CPU中使用的MESI缓存一致性协议。 先来说说缓存一致性问题。为了提高数据访问效率，每个CPU上都有一个容量很小（现在一般是1M这个数量级），速度很快的缓存，用于缓存最常访问的那些数据。由于操作内存的速度实在太慢，数据被修改时也只更新缓存，并不直接写出到内存中去，这一来就造成了缓存中的数据与内存不一致。如果系统中只有一个CPU，所有线程看到的都是缓存中的最新数据，当然没问题。但如果系统中有多个CPU，同一份内存可能会被缓存到多个CPU中，如果在不同CPU中运行的不同线程看到同一份内存的缓存值不一样就麻烦了，因此有必要维护这多种缓存的一致性。当然要做到这一点只要一有修改操作，就通知所有CPU更新缓存，或者放弃缓存下次访问的时候再重新从内存中读取。但这会Stupid的实现显然不会有好的性能，为解决这一问题，产生了很多维护缓存一致性的协议，MESI就是其中一种。</p>
<h3 id="2-MESI状态"><a href="#2-MESI状态" class="headerlink" title="2.MESI状态"></a><strong>2.MESI状态</strong></h3><p>MESI是“modified”, “exclusive”, “shared”, 和 “invalid”首字母的大写，当使用MESI cache-coherence 协议的时候，cacheline可以处于这四个状态中的一个，因此，HW工程师设计cache的时候，除了物理地址和具体的数据之外，还需要为每一个cacheline设计一个2-bit的tag来标识该cacheline的状态。 M: 被修改的。处于这一状态的数据只在本CPU中有缓存，且其数据已被修改，没有更新到内存中 E: 独占的。处于这一状态的数据只在本CPU中有缓存，且其数据没有被修改，与内存一致 S: 共享的。处于这一状态的数据在多个CPU中有缓存 I: 无效的。本CPU中的这份缓存已经无效了。 处于modified状态的cacheline说明近期有过来自对应cpu的写操作，同时也说明该该数据不会存在其他cpu对应的cache中。因此，处于modified状态的cacheline也可以说是被该CPU独占。而又因为只有该CPU的cache保存了最新的数据（最终的memory中都没有更新），所以，该cache需要对该数据负责到底。例如根据请求，该cache将数据及其控制权传递到其他cache中，或者cache需要负责将数据写回到memory中，而这些操作都需要在reuse该cache line之前完成。 exclusive状态和modified状态非常类似，唯一的区别是对应CPU还没有修改cacheline中的数据，也正因为还没有修改数据，因此memory中对应的data也是最新的。在exclusive状态下，cpu也可以不通知其他CPU cache而直接对cacheline进行操作，因此，exclusive状态也可以被认为是被该CPU独占。由于memory中的数据和cacheline中的数据都是最新的，因此，cpu不需对exclusive状态的cacheline执行写回的操作或者将数据以及归属权转交其他cpu cache，而直接reuse该cacheline（将cacheine中的数据丢弃，用作他用）。 处于share状态的cacheline，其数据可能在一个或者多个CPU cache中，因此，处于这种状态的cache line，CPU不能直接修改cacheline的数据，而是需要首先和其他CPU cache进行沟通。和exclusive状态类似，处于share状态的cacheline对应的memory中的数据也是最新的，因此，cpu也可以直接丢弃cacheline中的数据而不必将其转交给其他CPU cache或者写回到memory中。 处于invalid状态的cacheline是空的，没有数据。当新的数据要进入cache的时候，优选状态是invalid的cacheline，之所以如此是因为如果选中其他状态的cacheline，则说明需要替换cacheline数据，而未来如果再次访问这个被替换掉的cacheline数据的时候将遇到开销非常大的cache miss。 当CPU要读取数据时，只要缓存的状态不是I都可以从缓存中读，否则就要从主存中读。这一读操作可能会被某个处于M或E状态的CPU截获，该CPU将修改的数据写出到内存，并将自己设为S状态后这一读操作才继续进行。只有缓存状态是E或M时，CPU才可以修改其中的数据，修改后缓存即处于M状态。如果CPU要修改数据时发现其缓存不处于E或M状态，则需要发出特殊的RFO指令（Read For Ownership），将其它CPU的缓存设为I状态。 因此，如果一个变量在某段时间内只被一个线程频繁修改，则对应的缓存早就处于M状态，这时CAS操作就不会涉及到总线操作。所以频繁的加锁并不一定会影响系统并发度，关键是看锁冲突的情况严重不严重，如果经常出现冲突，即缓存一会被这个CPU独占，一会被那个CPU独占，这时才会不断产生RFO，影响到并发性能。 CPU原语-比较并交换(CompareAndSet),实现非阻塞算法 <strong>什么是CAS?</strong> cas是现代CPU提供给并发程序使用的原语操作. 不同的CPU有不同的使用规范. 在 Intel 处理器中，比较并交换通过指令的 cmpxchg 系列实现。 PowerPC 处理器有一对名为“加载并保留”和“条件存储”的指令，它们实现相同的目地； MIPS 与 PowerPC 处理器相似，除了第一个指令称为“加载链接”。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B) <strong>什么是非阻塞算法?</strong> 一个线程的失败或挂起不应该影响其他线程的失败或挂起.这类算法称之为非阻塞(nonblocking)算法 对比阻塞算法: 如果有一类并发操作, 其中一个线程优先得到对象监视器的锁, 当其他线程到达同步边界时, 就会被阻塞. 直到前一个线程释放掉锁后, 才可以继续竞争对象锁.(当然,这里的竞争也可是公平的, 按先来后到的次序) <strong>CAS 原理:</strong> 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 CAS使用示例(jdk 1.5 并发包 AtomicInteger类分析</p>
<p>/**<br>　　* Atomically sets to the given value and returns the old value.<br>　　*<br>　　* @param newValue the new value<br>　　* @return the previous value<br>　　*/ public final int getAndSet(int newValue) {<br>　　for (;;) {<br>　　int current = get();<br>　　if (compareAndSet(current, newValue))<br>　　return current;<br>　　}<br>　　}<br>　　public final boolean compareAndSet(int expect, int update) {<br>　　return unsafe.compareAndSwapInt(this, valueOffset, expect, update);<br>　　}</p>
<p>这个方法是, AtomicInteger类的常用方法, 作用是, 将变量设置为指定值, 并返回设置前的值. 它利用了cpu原语compareAndSet来保障值的唯一性. 另, AtomicInteger类中, 其他的实用方法, 也是基于同样的实现方式. 比如 getAndIncrement, getAndDecrement, getAndAdd等等. <strong>CAS语义上存在的”ABA 问题”</strong> 什么是ABA问题? 假设, 第一次读取V地址的A值, 然后通过CAS来判断V地址的值是否仍旧为A, 如果是, 就将B的值写入V地址,覆盖A值. 但是, 语义上, 有一个漏洞, 当第一次读取V的A值, 此时, 内存V的值变为B值, 然后在未执行CAS前, 又变回了A值. 此时, CAS再执行时, 会判断其正确的, 并进行赋值. 这种判断值的方式来断定内存是否被修改过, 针对某些问题, 是不适用的. 为了解决这种问题, jdk 1.5并发包提供了AtomicStampedReference(有标记的原子引用)类, 通过控制变量值的版本来保证CAS正确性. 其实, 大部分通过值的变化来CAS, 已经够用了. <strong>jdk1.5原子包介绍(基于volatile)</strong> 包的特色: 1, 普通原子数值类型AtomicInteger, AtomicLong提供一些原子操作的加减运算. 2, 使用了解决脏数据问题的经典模式-“比对后设定”, 即 查看主存中数据是否与预期提供的值一致,如果一致,才更新. 3, 使用AtomicReference可以实现对所有对象的原子引用及赋值.包括Double与Float, 但不包括对其的计算.浮点的计算,只能依靠同步关键字或Lock接口来实现了. 4, 对数组元素里的对象,符合以上特点的, 也可采用原子操作.包里提供了一些数组原子操作类 AtomicIntegerArray, AtomicLongArray等等. 5, 大幅度提升系统吞吐量及性能.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xiaohe</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">153</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaohe</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
